<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AutoStitch</title>
    <style>
#fullbody {
  display: flex;
  flex-direction: row;
  margin: 0;
  padding: 0;
}
body {
	font-family : Verdana, Geneva, Arial, Helvetica, sans-serif;
}
.xlarge {font-size: 20px; }
.large {font-size: 16px; }
.medium {font-size: 14px; }
.small {font-size: 12px; }
.xsmall {font-size: 10px; }
.errorMsg {
  color: red;
}
.goodMsg {
  color: green;
}
#viewport {
  margin-left: 4px; /* Offset to make space for the fixed UI */
  height: 100vh;  /* Full viewport height */
  flex-grow: 1;       /* Take remaining space */
  background-color: #aaaaaa; /* Optional background for the canvas */
  overflow: auto;     /* Allow scrollbars to appear when canvas overflows */
  position: relative; /* Enable positioning of child elements (canvas) */
}


#imageCanvas {
	width: 500px;  /* Prevent scaling */
	height: auto; /* Prevent scaling */
	position: absolute;
	top: 0;
	left: 50%;      /* Center horizontally */
	transform: translateX(-50%);
	image-rendering: crisp-edges;  /* Prevent smoothing of the image */
	background-color: #777;  /* Optional background */
}

#cropCanvas {
	width: auto;  /* Prevent scaling */
	height: auto; /* Prevent scaling */
	position: absolute;
	top: 0;
	left: 50%;
	transform: translateX(-50%);
	z-index: 10;
	display: none;
}

.TopRow {
  display: flex;
  flex-direction: column;
	border-spacing: 2px 0px;
}
.TopCol {
	width: 216px;
	border: 1px solid #0000FF;
	margin-bottom: 10px;
}
.rel-control-cont {
	height: 100%;
	width: 100%;
	position: relative;
}

.H27 {
   height: 27px;
}
.H45 {
   height: 45px;
}
.H55 {
   height: 55px;
}
.H63 {
   height: 63px;
}
.H85 {
	height: 85px;
}
.H80 {
	height: 80px;
}
.H163 {
	height: 163px;
}
.H177 {
	height: 177px;
}
.H402 {
	height: 462px;
}
#transparency-slider {
	position: absolute;
	top: 25px;
	left: 2px;
	width: 150px;
	margin: 0;
	padding: 0;
}
#trans411 {
    position: absolute;
    top: 26px;
    left: 155px;
}
#image-container {
	cursor: move;
	position: relative;
}
#zoomButton {
	position: absolute;
	top: 1px;
	left: 160px;
	width: 55px;
	height: 25px;
}
#nextButton {
	position: absolute;
	top: 10px;
	left: 160px;
	width: 55px;
	height: 30px;
}
#doneButton {
	position: absolute;
	top: 1px;
	left: 160px;
	width: 55px;
	height: 25px;
}
.dlBtn {
	width: 55px;
	height: 25px;
}
#confirmCheckbox {
	position: absolute;
	top: 5px;
	left: 183px;
}
#Zoom411 {
	position: absolute;
	top: 3px;
	left: 70px;
}
.line1big {
	position: absolute;
	top: 0px;
	left: 2px;
}
.line2ind {
	position: absolute;
	top: 25px;
	left: 12px;
}
.line2indSm {
	position: absolute;
	top: 19px;
	left: 12px;
}
.line3ind {
	position: absolute;
	top: 45px;
	left: 12px;
}
.line4indSm {
	position: absolute;
	top: 70px;
	left: 12px;
}

.TaCenter {
	text-align: center;
}
#PanU {
	top: 2px;
	left: 173px;
}
#PanL {
	top: 12px;
	left: 153px;
}
#PanR {
	top: 12px;
	left: 193px;
}
#PanD {
	top: 22px;
	left: 173px;
}
.arrow-button {
	border: 1px solid #000000;
	cursor: default;
	user-select: none;
}
.a-b-lg {
	position: absolute;
	width: 19px;
	height: 19px;
}
.a-b-sm {
	width: 9px;
	height: 9px;
	font-size: 9px;
}
.arrow-button:hover {
	border: 1px solid #FF0000;
}
.arrow-button.disabled {
	pointer-events: none;
	opacity: 0.5;
}
.arrow-button:active {
	color: red;
}

.stitchTools {
    display: block;
}
.cropTools {
    display: block;
}
.cutTools {
    display: none;
}
.textTools {
    display: none;
}

#cropcolor {
	position: absolute;
	top: 30px;
	left: 150px;
	width: 50px;
	height: 30px;
}
#bordercolor {
	position: absolute;
	top: 52px;
	left: 68px;
	width: 40px;
	height: 20px;
}
#textcolor {
	position: absolute;
	top: 52px;
	left: 170px;
	width: 40px;
	height: 20px;
}
#borderText {
	position: absolute;
	top: 52px;
	left: 12px;
}
#textText {
	position: absolute;
	top: 52px;
	left: 130px;
}
#fonttype {
	position: absolute;
	top: 27px;
	left: 55px;
	width: 156px;
}
#bordersize {
	position: absolute;
	top: 2px;
	left: 167px;
}
#stdNewsInput {
	position: absolute;
	top: 22px;
	left: 2px;
	width: 204px;
	border: 2px solid #F4A261;
	text-align: center;
}
#stdDateInput {
	position: absolute;
	top: 45px;
	left: 2px;
	width: 95px;
	border: 2px solid #A04FD9;
	text-align: right;
}
#stdDash {
	position: absolute;
	top: 45px;
	left: 104px;
	width: 95px;
}
#stdPageInput {
	position: absolute;
	top: 45px;
	left: 111px;
	width: 95px;
	border: 2px solid #42B3A4;
}
#stdRegion {
	position: absolute;
	top: 92px;
	left: 2px;
}
#stdNewsDrop {
	position: absolute;
	top: 115px;
	left: 2px;
	border: 2px solid #F4A261;
}

#stdfontSizeControls{
	position: absolute;
	top: 420px;
	left: 2px;
	display: flex;
	align-items: center;
	gap: 3px; /* Small spacing */
}
.custFontContGroup {
	display: flex;
	gap: 0px;
	
}
.fontSizeDisplay {
    width: 22px;  /* Same as input size */
    height: 21px; /* Matches input height */
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid #000;
    background-color: #fff;
    font-size: 14px; /* Standard height */
    text-align: center;
    font-family: inherit;
    user-select: none; /* Prevent selection */
    cursor: default; /* No text input cursor */
}

.sizeArrows {
    display: flex;
    flex-direction: column;
}
.custom-overlay { /* Overlay for disabled custom text lines */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.4); /* black with 60% opacity */
    pointer-events: auto; /* So text looks selectable but isn&#8217;t */
    display: none; /* Hidden by default */
}

/* Active when the line is disabled */
.custom-line.inactive .custom-overlay {
    display: block;
}
.custom-line {
    position: relative; /* Ensures overlay is relative to this */
}
.date-btn {
    height: 18px;
    margin: 1px;
    border: 1px solid #333;
    background-color: #f0f0f0;
    cursor: pointer;
    border-radius: 4px; /* Rounded corners */
    text-align: center;
}
.page-btn {
    height: 18px;
    margin: 1px;
    border: 1px solid #333;
    background-color: #f0f0f0;
    cursor: pointer;
    border-radius: 4px; /* Rounded corners */
    text-align: center;
}
.date-btn:hover {
    background-color: #ddd;
}
.page-btn:hover {
    background-color: #ddd;
}
.date-btn.date-btn-active {
    background-color: #AADDAA;
}
/* Individual button widths */
.btn-single {
    width: 18px;
}
.btn-double {
    width: 24px;
}
.btn-triple {
    width: 31px;
}
.btn-backspace {
    width: 45px;
    display: flex;
    align-items: center; /* Centers it vertically */
    justify-content: center; /* Centers horizontally */
    font-size: 1em;
}
.btn-backspace span {
    position: relative;
    top: -1px;
}
.no-tab { }
/* Align the header correctly */
.date-header {
	width: 100%;
    text-align: center;
    font-weight: normal;
}
#datePickerContainer {
	position: absolute;
	top: 140px;
	left: 2px;
	display: flex;
	flex-wrap: wrap;
	justify-content: left;
	border: 2px solid #A04FD9;
	width: 156px;
	height: 260px;
}

#pagePickerContainer {
	position: absolute;
	top: 140px;
	left: 165px;
	display: flex;
	flex-wrap: wrap;
	justify-content: left;
	border: 2px solid #42B3A4;
	width: 45px;
	height: 260px;
}
.row-p1 {
	width: 20px;
	margin-left: 2px;
}
.row-p2 {
	width: 20px;
}
.row-d1 {
	width: 20px;
	margin-left: 2px;
}
.row-d2 {
	width: 20px;
	margin-right: 6px;
}
.row-mmm {
	width: 33px;
	margin-right: 6px;
}
.row-yy {
	width: 26px;
}
.row-y3 {
	width: 20px;
}
.row-y4 {
	width: 20px;
}
#stdItalics {
	position: absolute;
	top: 92px;
	left: 180px;
}
.toggle-button, .standard-toggle {
    padding: 2px 2px;
    margin: 0px;
    height: 22px;
    width: 22px;
    border: 2px solid #ccc;
    background-color: #e9e9e9;
    cursor: pointer;
    border-radius: 2px;
}

.toggle-button.active, .standard-toggle.active {
    background-color: #AADDAA; /* Green when active */
    border-color: #4CAF50; /* Slightly darker green border */
}
.customBlueLine {
    width: 100%;
    border-top: 1px dashed blue;
}
#CustomBox {
    display: flex;
    flex-direction: column; /* Stack vertically */
    gap: 2px; /* Optional: Spacing between elements */
}
.downloadBox {
    display: flex;
    flex-direction: column; /* Stack vertically */
    gap: 5px; /* Optional: Spacing between elements */
}
.spread {
    display: flex;
    justify-content: space-around; /* Applies equal padding & gaps */
    width: 100%; /* Or whatever width */
}
.headerPlus {
    display: flex;
    justify-content: space-between; /* Push left & right */
    width: 100%;
}
.cusLinesCBs {
	display: flex;
	gap: 0px;
}
.custom-text { /* each custom text input */
	width: 205px;
}
.custom-text-controls {
	display: flex;
	width: 100%;
	justify-content: space-between;
}
#customLayout {
	display: none;
}
.RotL01_00 {
	top: 8px;
	left: 97px;
}
.RotR01_00 {
	top: 8px;
	left: 167px;
}
.RotL00_10 {
	top: 28px;
	left: 102px;
}
.RotR00_10 {
	top: 28px;
	left: 162px;
}
.RotL00_01 {
	top: 49px;
	left: 107px;
}
.RotR00_01 {
	top: 49px;
	left: 157px;
}
.rotate-text2 {
	position: absolute;
	top: 13px;
	left: 130px;
}
.rotate-text3 {
	position: absolute;
	top: 32px;
	left: 27px;
}
</style>

</head>
<body id="fullbody">
<div class="TopRow">

<!------------------------>
<!--     STATUS BOX     -->
<!------------------------>
<div id="statusBox" class="TopCol H45"><div class="rel-control-cont">
    <div class="line1big xlarge">Status</div>
    <div class="line2ind" id="status411">Loading...</div>
</div></div>

<!------------------------>
<!--      DONE BOX      -->
<!------------------------>
	<div id="doneBox" class="TopCol H27"><div class="rel-control-cont">
		<div class="line1big xlarge">When Finished</div>
		<input type="button" id="doneButton" value="Done">
	</div></div>


<!--     STITCH ONLY TOOLS     -->
<div id="allStitchTools">
<!------------------------>
<!--    MATCHES BOX     -->
<!------------------------>
<div id="matchesBox" class="TopCol H63 stitchTools"><div class="rel-control-cont">
    <div class="line1big xlarge">Matches</div>
    <div class="line2ind">
		Snip: <span id="snip411"><i>pending</i></span>
		<br>Chunk: <span id="chunk411"><i>pending</i></span>
	</div>
</div></div>

<!------------------------>
<!--    CONF CONTROL    -->
<!------------------------>
<div id="confContBox" class="TopCol H27 stitchTools"><div class="rel-control-cont">
	<div class="line1big xlarge">Confirmation On? <input type="checkbox" id="confirmCheckbox"></div>
</div></div>

<!------------------------>
<!--     NUDGE BOX      -->
<!------------------------>
	<div id="nudgeBox" class="TopCol TaCenter H45 stitchTools"><div class="rel-control-cont">
		<div id="PanU" class="arrow-button a-b-lg">&#9650;</div>
		<div id="PanL" class="arrow-button a-b-lg">&#9668;</div>
		<div id="PanR" class="arrow-button a-b-lg">&#9658;</div>
		<div id="PanD" class="arrow-button a-b-lg">&#9660;</div>
		<div class="line1big xlarge">Nudge</div>
	</div></div>

<!------------------------>
<!--  TRANSPARENCY BOX  -->
<!------------------------>
	<div id="tranparencyBox" class="TopCol H45 stitchTools"><div class="rel-control-cont">
		<div class="line1big xlarge">BImg Transparency</div>
        <input type="range" id="transparency-slider" min="0" max="100" value="20">
		<div id="trans411">20</div>
	</div></div>

<!------------------------>
<!--      NEXT BOX      -->
<!------------------------>
	<div id="nextBox" class="TopCol H45 stitchTools"><div class="rel-control-cont">
		<div class="line1big xlarge">Next</div>
		<div class="line2ind">When aligned... </div>
		<input type="button" id="nextButton" value="Next">
	</div></div>

<!------------------------>
<!--   ZOOM INFO BOX    -->
<!------------------------>
	<div id="zoomBox" class="TopCol H27 stitchTools"><div class="rel-control-cont">
		<div class="line1big xlarge">Zoom:</div>
		<div id="Zoom411">nn.nn%</div>
		<input type="button" id="zoomButton" value="100%">
	</div></div>

<!------------------------>
<!--    LOCATION BOX    -->
<!------------------------>
<div id="locationBox" class="TopCol H80 stitchTools"><div class="rel-control-cont">
    <div class="line1big">Location</div>
    <div class="line2indSm small">
		TImg: <span id="timgLoc411"><i>n/a</i></span>
		<br>BImg S: <span id="bimgPrev411"><i>n/a</i></span>
		<br>BImg E: <span id="bimgPost411"><i>n/a</i></span>
		<br>Offset: H: <span id="Hoffset411"><i>n/a</i></span> V: <span id="Voffset411"><i>n/a</i></span></div>
	</div></div>
</div> <!-- END allStitchTools id -->


<!--    ROTATE & CROP ONLY TOOLS    -->
<div id="allCropTools">
<!------------------------>
<!--      CROP BOX      -->
<!------------------------>
<div id="CropBox" class="TopCol H80 cropTools"><div class="rel-control-cont">
	<div class="line1big xlarge">Croplines</div>
	<input type="color" id="cropcolor" value="#008000">
	<div class="line2ind"><input type="radio" id="CropOn" name="CropToggle" value="on" CHECKED>ON</div>
	<div class="line3ind"><input type="radio" id="CropOff" name="CropToggle" value="off">OFF</div>
</div></div>

<!------------------------>
<!--     ROTATE BOX     -->
<!------------------------>
<div id="RotateBox" class="TopCol H80 cropTools TaCenter"><div class="rel-control-cont">
	<div id="RotL01.00" class="RotL01_00 arrow-button a-b-lg">&#9668;</div>
	<div id="RotR01.00" class="RotR01_00 arrow-button a-b-lg">&#9658;</div>
	<div id="RotL00.10" class="RotL00_10 arrow-button a-b-lg">&#9668;</div>
	<div id="RotR00.10" class="RotR00_10 arrow-button a-b-lg">&#9658;</div>
	<div id="RotL00.01" class="RotL00_01 arrow-button a-b-lg">&#9668;</div>
	<div id="RotR00.01" class="RotR00_01 arrow-button a-b-lg">&#9658;</div>
	<div class="line1big xlarge">Rotate</div>
	<div class="rotate-text2 medium">1<br>.1<br>.01</div>
	<div id="Rot411" class="rotate-text3 large">0&deg;</div>
</div></div>

</div><!--    end ROTATE & CROP TOOLS       -->
<!--    CUT ONLY TOOLS Temp Suspended -->

<!------------------------>
<!--      CUT BOX       -->
<!------------------------>
<div id="CutBox" class="TopCol H80 cutTools"><div class="rel-control-cont">
	<div class="line1big xlarge">Text</div>
</div></div>

<!--    end CUT ONLY TOOLS   -->
<!--    TEXT ONLY TOOLS      -->
<div id="allTextTools">
<!------------------------>
<!--  Border/Text BOX   -->
<!------------------------>
<div id="TextBox" class="TopCol H80"><div class="rel-control-cont">
	<div class="line1big xlarge">Border/Text</div>
	<div class="line2ind">Font:</div>
	<div id="borderText">Border</div>
	<div id="textText">Text</div>
	<select id="bordersize"></select>
	<select id="fonttype"></select>
	<input type="color" id="bordercolor" value="#000000">
	<input type="color" id="textcolor" value="#FFFFFF">
</div></div>

<!------------------------>
<!-- Stnd vs. Cust BOX  -->
<!------------------------>
<div id="TextBox" class="TopCol H45"><div class="rel-control-cont">
	<div class="line1big xlarge">Layout</div>
	<div class="line2ind"><input type="radio" name="appendLayout" value="standard"> Standard <input type="radio" name="appendLayout" value="custom" checked> Custom</div>
</div></div>

<div id="standardLayout">

<!------------------------>
<!--   Stnd Txt Inputs  -->
<!------------------------>
<div id="TextBox" class="TopCol H402"><div class="rel-control-cont">
	<div class="line1big xlarge">Standard</div>
	<input type="text" id="stdNewsInput" placeholder="Newspaper Name" maxlength="100">
	<input type="text" id="stdDateInput" placeholder="dd Mmm yyyy" maxlength="20">
	<div id="stdDash">-</div>
	<input type="text" id="stdPageInput" placeholder="Page n" maxlength="15">
	<div class="line4indSm small">Enter text here or click below.</div>

	<select id="stdRegion"></select>
	<select id="stdNewsDrop"></select>
<div id="datePickerContainer">
	<!-- Day Selection -->
	<div class="row-d1">
		<div class="date-header">d</div>
		<button class="date-btn btn-single" data-group="day-tens" data-value="0">0</button>
		<button class="date-btn btn-single" data-group="day-tens" data-value="1">1</button>
		<button class="date-btn btn-single" data-group="day-tens" data-value="2">2</button>
		<button class="date-btn btn-single" data-group="day-tens" data-value="3">3</button>
	</div>
	<div class="row-d2">
		<div class="date-header">d</div>
		<button class="date-btn btn-single" data-group="day-ones" data-value="0">0</button>
		<button class="date-btn btn-single" data-group="day-ones" data-value="1">1</button>
		<button class="date-btn btn-single" data-group="day-ones" data-value="2">2</button>
		<button class="date-btn btn-single" data-group="day-ones" data-value="3">3</button>
		<button class="date-btn btn-single" data-group="day-ones" data-value="4">4</button>
		<button class="date-btn btn-single" data-group="day-ones" data-value="5">5</button>
		<button class="date-btn btn-single" data-group="day-ones" data-value="6">6</button>
		<button class="date-btn btn-single" data-group="day-ones" data-value="7">7</button>
		<button class="date-btn btn-single" data-group="day-ones" data-value="8">8</button>
		<button class="date-btn btn-single" data-group="day-ones" data-value="9">9</button>
		</div>

	<div class="row-mmm">
		<div class="date-header">Mon</div>
		<button class="date-btn btn-triple" data-group="months" data-value="Jan">Jan</button>
		<button class="date-btn btn-triple" data-group="months" data-value="Feb">Feb</button>
		<button class="date-btn btn-triple" data-group="months" data-value="Mar">Mar</button>
		<button class="date-btn btn-triple" data-group="months" data-value="Apr">Apr</button>
		<button class="date-btn btn-triple" data-group="months" data-value="May">May</button>
		<button class="date-btn btn-triple" data-group="months" data-value="Jun">Jun</button>
		<button class="date-btn btn-triple" data-group="months" data-value="Jul">Jul</button>
		<button class="date-btn btn-triple" data-group="months" data-value="Aug">Aug</button>
		<button class="date-btn btn-triple" data-group="months" data-value="Sep">Sep</button>
		<button class="date-btn btn-triple" data-group="months" data-value="Oct">Oct</button>
		<button class="date-btn btn-triple" data-group="months" data-value="Nov">Nov</button>
		<button class="date-btn btn-triple" data-group="months" data-value="Dec">Dec</button>
	</div>

	<div class="row-yy">
		<div class="date-header">yy</div>
		<button class="date-btn btn-double" data-group="centuries" data-value="18">18</button>
		<button class="date-btn btn-double" data-group="centuries" data-value="19">19</button>
		<button class="date-btn btn-double" data-group="centuries" data-value="20">20</button>
	</div>

	<div class="row-y3">
		<div class="date-header">y</div>
		<button class="date-btn btn-single" data-group="year-tens" data-value="0">0</button>
		<button class="date-btn btn-single" data-group="year-tens" data-value="1">1</button>
		<button class="date-btn btn-single" data-group="year-tens" data-value="2">2</button>
		<button class="date-btn btn-single" data-group="year-tens" data-value="3">3</button>
		<button class="date-btn btn-single" data-group="year-tens" data-value="4">4</button>
		<button class="date-btn btn-single" data-group="year-tens" data-value="5">5</button>
		<button class="date-btn btn-single" data-group="year-tens" data-value="6">6</button>
		<button class="date-btn btn-single" data-group="year-tens" data-value="7">7</button>
		<button class="date-btn btn-single" data-group="year-tens" data-value="8">8</button>
		<button class="date-btn btn-single" data-group="year-tens" data-value="9">9</button>
	</div>

	<div class="row-y4">
		<div class="date-header">y</div>
		<button class="date-btn btn-single" data-group="year-ones" data-value="0">0</button>
		<button class="date-btn btn-single" data-group="year-ones" data-value="1">1</button>
		<button class="date-btn btn-single" data-group="year-ones" data-value="2">2</button>
		<button class="date-btn btn-single" data-group="year-ones" data-value="3">3</button>
		<button class="date-btn btn-single" data-group="year-ones" data-value="4">4</button>
		<button class="date-btn btn-single" data-group="year-ones" data-value="5">5</button>
		<button class="date-btn btn-single" data-group="year-ones" data-value="6">6</button>
		<button class="date-btn btn-single" data-group="year-ones" data-value="7">7</button>
		<button class="date-btn btn-single" data-group="year-ones" data-value="8">8</button>
		<button class="date-btn btn-single" data-group="year-ones" data-value="9">9</button>
	</div>
</div>



<div id="pagePickerContainer">
<div class="date-header">Page</div>
	<div class="row-p1">
		<button class="page-btn btn-single" data-group="page-text" data-value="A">A</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="B">B</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="C">C</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="D">D</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="E">E</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="F">F</button>
	</div>
	<div class="row-p2">
		<button class="page-btn btn-single" data-group="page-text" data-value="0">0</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="1">1</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="2">2</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="3">3</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="4">4</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="5">5</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="6">6</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="7">7</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="8">8</button>
		<button class="page-btn btn-single" data-group="page-text" data-value="9">9</button>
	</div>
<button class="btn-backspace page-btn" data-group="page-text" data-value="del"> &#9003; </button>
</div>
<button id="stdItalics" class="standard-toggle"><i>I</i></button>

<div id="stdfontSizeControls">
    Size: AutoFit
    <input type="checkbox" id="stdAutoFit" checked>
	<div id="stdFontSizeDiv" class="fontSizeDisplay">24</div>
    <div class="sizeArrows">
        <div id="stdFontInc" class="arrow-button a-b-sm">&#9650;</div>
        <div id="stdFontDec" class="arrow-button a-b-sm">&#9660;</div>
    </div>
</div>
</div></div>


</div><!-- end Standard Layout Tools -->
<div id="customLayout">

<!------------------------>
<!--   Cust Txt Inputs  -->
<!------------------------>
<div id="CustomBox" class="TopCol H402">

	<div class="xlarge">Custom</div>
	<div class="cusLinesCBs">Lines:
		<input type="checkbox" class="custom-line-toggle" id="customLine1Toggle">
		<input type="checkbox" class="custom-line-toggle" id="customLine2Toggle">
		<input type="checkbox" class="custom-line-toggle" id="customLine3Toggle">
		<input type="checkbox" class="custom-line-toggle" id="customLine4Toggle">
		<input type="checkbox" class="custom-line-toggle" id="customLine5Toggle">
	</div>
	<div class="customBlueLine"></div>

	<div class="custom-line" id="custom1">
		<div class="custom-overlay" id="customOverlay1"></div>
		<input type="text" class="custom-text" id="customText1" placeholder="Line 1" maxlength="255">
		<div class="custom-text-controls">
			<div class="custFontContGroup">
			    <span class="small">Auto</span>
			    <input type="checkbox" id="AutoFit1" class="no-tab" checked>
				<div id="custFontSize1" class="fontSizeDisplay">24</div>
			    <div class="sizeArrows">
			        <div id="customFontInc1" class="arrow-button a-b-sm">&#9650;</div>
			        <div id="customFontDec1" class="arrow-button a-b-sm">&#9660;</div>
			    </div>
			</div>
			<div class="custFontContGroup">
				<button id="customBold1" class="toggle-button"><b>B</b></button>
				<button id="customItalic1" class="toggle-button"><i>I</i></button>
			</div>
			<div class="custFontContGroup">
				<button id="customAlignLeft1" class="toggle-button" data-group="customAlign1" data-value="left">L</button>
				<button id="customAlignCenter1" class="toggle-button" data-group="customAlign1" data-value="center">C</button>
				<button id="customAlignRight1" class="toggle-button" data-group="customAlign1" data-value="right">R</button>
			</div>
		</div><!-- end custom-text-controls -->
	</div><!-- end custom Line 1 -->

	<div class="customBlueLine"></div>

	<div class="custom-line" id="custom2">
		<div class="custom-overlay" id="customOverlay2"></div>
		<input type="text" class="custom-text" id="customText2" placeholder="Line 2" maxlength="255">
		<div class="custom-text-controls">
			<div class="custFontContGroup">
			    <span class="small">Auto</span>
			    <input type="checkbox" id="AutoFit2" class="no-tab" checked>
				<div id="custFontSize2" class="fontSizeDisplay">24</div>
			    <div class="sizeArrows">
			        <div id="customFontInc2" class="arrow-button a-b-sm">&#9650;</div>
			        <div id="customFontDec2" class="arrow-button a-b-sm">&#9660;</div>
			    </div>
			</div>
			<div class="custFontContGroup">
				<button id="customBold2" class="toggle-button"><b>B</b></button>
				<button id="customItalic2" class="toggle-button"><i>I</i></button>
			</div>
			<div class="custFontContGroup">
				<button id="customAlignLeft2" class="toggle-button" data-group="customAlign2" data-value="left">L</button>
				<button id="customAlignCenter2" class="toggle-button" data-group="customAlign2" data-value="center">C</button>
				<button id="customAlignRight2" class="toggle-button" data-group="customAlign2" data-value="right">R</button>
			</div>
		</div><!-- end custom-text-controls -->
	</div><!-- end custom Line 2 -->

	<div class="customBlueLine"></div>
	<div class="custom-line" id="custom3">
		<div class="custom-overlay" id="customOverlay3"></div>
		<input type="text" class="custom-text" id="customText3" placeholder="Line 3" maxlength="255">
		<div class="custom-text-controls">
			<div class="custFontContGroup">
			    <span class="small">Auto</span>
			    <input type="checkbox" id="AutoFit3" class="no-tab" checked>
				<div id="custFontSize3" class="fontSizeDisplay">24</div>
			    <div class="sizeArrows">
			        <div id="customFontInc3" class="arrow-button a-b-sm">&#9650;</div>
			        <div id="customFontDec3" class="arrow-button a-b-sm">&#9660;</div>
			    </div>
			</div>
			<div class="custFontContGroup">
				<button id="customBold3" class="toggle-button"><b>B</b></button>
				<button id="customItalic3" class="toggle-button"><i>I</i></button>
			</div>
			<div class="custFontContGroup">
				<button id="customAlignLeft3" class="toggle-button" data-group="customAlign3" data-value="left">L</button>
				<button id="customAlignCenter3" class="toggle-button" data-group="customAlign3" data-value="center">C</button>
				<button id="customAlignRight3" class="toggle-button" data-group="customAlign3" data-value="right">R</button>
			</div>
		</div><!-- end custom-text-controls -->
	</div><!-- end custom Line 3 -->

	<div class="customBlueLine"></div>
	<div class="custom-line" id="custom4">
		<div class="custom-overlay" id="customOverlay4"></div>
		<input type="text" class="custom-text" id="customText4" placeholder="Line 4" maxlength="255">
		<div class="custom-text-controls">
			<div class="custFontContGroup">
			    <span class="small">Auto</span>
			    <input type="checkbox" id="AutoFit4" class="no-tab" checked>
				<div id="custFontSize4" class="fontSizeDisplay">24</div>
			    <div class="sizeArrows">
			        <div id="customFontInc4" class="arrow-button a-b-sm">&#9650;</div>
			        <div id="customFontDec4" class="arrow-button a-b-sm">&#9660;</div>
			    </div>
			</div>
			<div class="custFontContGroup">
				<button id="customBold4" class="toggle-button"><b>B</b></button>
				<button id="customItalic4" class="toggle-button"><i>I</i></button>
			</div>
			<div class="custFontContGroup">
				<button id="customAlignLeft4" class="toggle-button" data-group="customAlign4" data-value="left">L</button>
				<button id="customAlignCenter4" class="toggle-button" data-group="customAlign4" data-value="center">C</button>
				<button id="customAlignRight4" class="toggle-button" data-group="customAlign4" data-value="right">R</button>
			</div>
		</div><!-- end custom-text-controls -->
	</div><!-- end custom Line 4 -->

	<div class="customBlueLine"></div>
	<div class="custom-line" id="custom5">
		<div class="custom-overlay" id="customOverlay5"></div>
		<input type="text" class="custom-text" id="customText5" placeholder="Line 5" maxlength="255">
		<div class="custom-text-controls">
			<div class="custFontContGroup">
			    <span class="small">Auto</span>
			    <input type="checkbox" id="AutoFit5" class="no-tab" checked>
				<div id="custFontSize5" class="fontSizeDisplay">24</div>
			    <div class="sizeArrows">
			        <div id="customFontInc5" class="arrow-button a-b-sm">&#9650;</div>
			        <div id="customFontDec5" class="arrow-button a-b-sm">&#9660;</div>
			    </div>
			</div>
			<div class="custFontContGroup">
				<button id="customBold5" class="toggle-button"><b>B</b></button>
				<button id="customItalic5" class="toggle-button"><i>I</i></button>
			</div>
			<div class="custFontContGroup">
				<button id="customAlignLeft5" class="toggle-button" data-group="customAlign5" data-value="left">L</button>
				<button id="customAlignCenter5" class="toggle-button" data-group="customAlign5" data-value="center">C</button>
				<button id="customAlignRight5" class="toggle-button" data-group="customAlign5" data-value="right">R</button>
			</div>
		</div><!-- end custom-text-controls -->
	</div><!-- end custom Line 5 -->

	<div class="customBlueLine"></div>

</div><!-- end customBox -->


</div><!-- end Custom Layout Tools -->
</div><!--    end TEXT ONLY TOOLS   -->
<!--    cont. ALL TOOLS       -->

<!------------------------>
<!--   DIMENSIONS BOX   -->
<!------------------------>
<div id="dimensionsBox" class="TopCol H80"><div class="rel-control-cont">
    <div class="line1big">Dimensions</div>
    <div class="line2indSm small">
		Canvas: <span id="canvSize411">100x100</span>
		<br>TImg: <span id="timgSize411"><i>n/a</i></span>
		<span id="hideBimg411"><br>BImg: <span id="bimgSize411"><i>n/a</i></span></span>
		<br>Image Count: <span id="imgCount411">0</span>
	</div>
</div></div>

<div id="downloadTools">
<!------------------------>
<!--    DOWNLOAD BOX    -->
<!------------------------>
<div class="TopCol H163 downloadBox">
	<div class="xlarge">Download</div>
	<div class = "small" align="center">Enter Filename (optional)</div>
	<input type="text" class="custom-text" id="dlFilename" placeholder="Clip_time" maxlength="255">
	<div class = "small" align="center">Choose Filetype</div>
	<div class="spread">
		<input type="button" id="jpgBtn" class="dlBtn" value=".jpg">
		<input type="button" id="pngBtn" class="dlBtn" value=".png">
	</div>
	<div class="spread small">
		<span id="jpgSize">-- KB</span>
		<span id="pngSize">-- KB</span>
	</div>
	<div class="small" align="center">(Estimated File Sizes)</div>
</div>

<!------------------------>
<!--     RELOAD BOX     -->
<!------------------------>
<div class="TopCol H177 downloadBox">
	<div class="xlarge">That was fun...</div>
	<div align="center"><input type="button" id="George" value="Let's Do it Again!"></div>
	<div class="xsmall">My coding partner wanted to name this button 'George.' I have no idea why. I tried to tell him that while George is a perfectly acceptable name, it's neither an intuitive or terribly appropriate name for a button that will start this whole process over again. He eventually relented but likely not happy about the situation. So, if you don't mind, please refer to this button as 'George' from time to time. Thank you.</div>
</div>

</div> <!--  END download Tools -->
</div> <!--  END OF TOP ROW    -->

<!--------------------------->
<!--        VIEWPORT       -->
<!--  w/imageCanvas inside -->
<!--------------------------->
<div id="viewport">
	<canvas id="imageCanvas"></canvas>
	<canvas id="cropCanvas"></canvas>
</div>
</body>
</html>

<script>
// Constants and initial variables

/////////////////////////////////////////////////////////
//                                                     //
//                USER SET VARIABLES                   //
//                                                     //
/////////////////////////////////////////////////////////

/////// The "I find myself changing this everytime" variables  //////

let borderSize = 25; // this is FINAL border size - changeable on page - make sure it fits in scenario below...
const borderSizeMin = 0; // min final border
const borderSizeMax = 50; // max final border
const borderSizeInc = 5; // step by n 

let imageBgColor = "#000000"; // basic black...
let textAppendColor = "#FFFFFF"; // basic white...

const standardFonts = [
	"Arial", 
	"Times New Roman", 
	"Courier New", 
	"Verdana", 
	"Georgia", 
	"Trebuchet MS", 
	"Tahoma"
];
// Custom fonts are available if you wish to use them.
// The 2 lines below need to be uncommented (remove the '//' preceding them)
// 'path/to/coolfont.ttf' gets replaced with your path
// "Cool Font" gets replaced with your font name

//const customFontPath = "path/to/coolfont.ttf"; // Path to your font
//const customFontName = "Cool Font"; // Name of your font

let selectedFont = "Courier New";
let minFontSize = 10;
let maxFontSize = 72;

let jpgQuality = 0.9; // Default to 90% quality

let currentAppendLayout = "custom"; // "standard" or "custom"

let customLinesEnabled = [true, true, false, false, false];
let customFontSizes = [24, 24, 24, 24, 24];
let autoFitEnabled = [false, false, false, false, false];
let customBold = [true, true, false, false, false];
let customItalic = [true, false, false, false, false];
let customAlignment = ["center", "center", "center", "center", "center"];
let customText = ["", "", "", "", ""];

let stdItalicsVar = true;
let stdBold = true;
let stdFontSizeVar = 24;
let stdAutoFitEnabled = false;
let stdNewsVar = ""; // will NOT work unless no standard REGIONS/PAPERS are set
let stdDateVar = "";
let stdPageVar = "";
let stdAlignment = "center";

const newspaperRegions = {
    "New York": "NY_Region",		// comma
    "Los Angeles": "LA_Region",	// comma
    "Chicago": "Chicago_Region"	// NO COMMA (last entry)
};

let selectedRegion = "New York"; // Default, but changeable

// Define the newspapers for each region
window.NY_Region = [
    "NY Times",				// comma
    "NY Post",					// comma
    "NY Daily News"				// NO COMMA (last entry)
];

window.LA_Region = [
    "LA Times",				// watch your commas!
    "LA Couriers",
    "LA Daily News"
];

window.Chicago_Region = [
    "Chicago Sun-Times",			// thank you for attending my comma talk
    "Chicago Tribune",
    "Chicago Reader"
];




/////// The "Technically, you COULD change these..." variables  //////

const confirmBeforeStitch = null; // set to 'false' (no quotes) to skip conf process or 'true' to ALWAYS confirm

let cropLineColor = "#000066"; // something dark...
const cropLineWidth = 1;
const cropOpacity = 0.8;  // Default opacity for shading


/////// The "Um, you probably don't want to mess with these" variables  //////

const dispPadding = 50; // even number > 20 (trust me)
const searchWidthPercentage = 0.9; // standard 90% for the search width
const snippetWidthPercentage = 0.5; // standard 50% for the snippet width
const chunkHeight = 10; // standard
const searchHeight = 50; // standard


/////// END OF USER VARIABLES - CHANGE STUFF BELOW AT YOUR PERIL!
/////// perhaps "peril" is too much, but stuff could stop working... FYI

/////////////////////////////////////////////////////////
//                                                     //
//         GEBI variables - set for later              //
//                                                     //
/////////////////////////////////////////////////////////

// "update411" status UI displays - all finalized in w.o
let status411_gebi;									// status 411
let snip411_gebi, chunk411_gebi;						// matching 411
let timgLoc411_gebi, bimgPrev411_gebi, bimgPost411_gebi;	// position 411
let Hoffset411_gebi, Voffset411_gebi;					// offset 411
let canvSize411_gebi, timgSize411_gebi, bimgSize411_gebi;	// size 411
let trans411_gebi, imgCount411_gebi, Rot411_gebi;			// misc 411

// buttons and sliders and boxes - oh my!
let doneButton, nextButton;
let confirmCheckbox, transparencySlider;
let nudgeU, nudgeL, nudgeR, nudgeD;
let stdNewsInput, stdDateInput, stdPageInput;
let fontTypeSelect;
let dlFilename, defaultFilename;
let jpgSizeSpan, pngSizeSpan;


let stitchTools, cropTools, textTools, downloadTools, dimensionsBox; // UI "groups"
let viewport, imageCanvas, ctx, cropCanvas, cropCtx;


let CurrRotAngle = 0; // Track rotation angle of the image
let confOpacity = .9; // for confirmation
let imgCount = 0; // Number of images processed so far (starting at 0)
let pasteListenerActive = false; // Keeps track of whether the paste listener is active
let matchTolerance = .025; // if set above .05, errors are highly likely - don't ask... it's JS

let currStage = 'stitch'; // then 'crop', 'cut', 'text'
let isValidated = false;
let TImg, BImg;
let BsnippetData = {
    width: 0,
    height: 0,
    data: [],
    startX: 0,
    startY: 0
};
let BchunkData = {
    data: []
};
let searchArea = {}; // Declare globally
let TImgSS = {
	startX: 0,
	startY: 0
};
let adjustedBImgX;
let adjustedBImgY;
let HOffset;
let VOffset;
let CropLinesPos = {
    l: 0,  // Left position
    r: 0,  // Right position
    t: 0,  // Top position
    b: 0  // Bottom position
};


// Constants for DOM elements (UI elements)

const zoomButton = document.getElementById('zoomButton');






/////////////////////////////////////////////////////////
//                                                     //
//  Sect. 1 - WINDOW.ONLOAD FUNCTION                   //
//                                                     //
/////////////////////////////////////////////////////////

window.onload = function() {
console.log("%c[INIT] Page Loaded. Starting setup...", "color: green");
console.log("%c[SETUP] Assigning variables and GEBI references...", "color: blue");
	/////////////////////////////////////////////////////////
	//             Set the GEBI vars et al                 //
	/////////////////////////////////////////////////////////

	status411_gebi = document.getElementById('status411');
	snip411_gebi = document.getElementById('snip411');
	chunk411_gebi = document.getElementById('chunk411');
	timgLoc411_gebi = document.getElementById('timgLoc411');
	bimgPrev411_gebi = document.getElementById('bimgPrev411');
	bimgPost411_gebi = document.getElementById('bimgPost411');
	Hoffset411_gebi = document.getElementById('Hoffset411');
	Voffset411_gebi = document.getElementById('Voffset411');
	canvSize411_gebi = document.getElementById('canvSize411');
	timgSize411_gebi = document.getElementById('timgSize411');
	bimgSize411_gebi = document.getElementById('bimgSize411');
	trans411_gebi = document.getElementById('trans411');
	imgCount411_gebi = document.getElementById('imgCount411');
	Rot411_gebi = document.getElementById('Rot411');

	nextButton = document.getElementById('nextButton');
	doneButton = document.getElementById('doneButton');
	transparencySlider = document.getElementById('transparency-slider');
	nudgeU = document.getElementById('PanU');
	nudgeL = document.getElementById('PanL');
	nudgeR = document.getElementById('PanR');
	nudgeD = document.getElementById('PanD');
	confirmCheckbox = document.getElementById('confirmCheckbox');

	const cropColorInput = document.getElementById("cropcolor");
	const borderSizeSelect = document.getElementById('bordersize');
	fontTypeSelect = document.getElementById('fonttype');
	const borderColorInput = document.getElementById("bordercolor");
	const textColorInput = document.getElementById("textcolor");

	const standardLayoutDiv = document.getElementById('standardLayout');
	const customLayoutDiv = document.getElementById('customLayout');

	stdNewsInput = document.getElementById("stdNewsInput");
	stdDateInput = document.getElementById("stdDateInput");
	stdPageInput = document.getElementById("stdPageInput");
	const stdItalicsBtn = document.getElementById("stdItalics");
	const stdAutoFitChk = document.getElementById("stdAutoFit");
	const stdFontIncBtn = document.getElementById("stdFontInc");
	const stdFontDecBtn = document.getElementById("stdFontDec");
	const stdFontSizeDiv = document.getElementById("stdFontSizeDiv");

	dlFilename = document.getElementById('dlFilename');
	const jpgBtn = document.getElementById('jpgBtn');
	const pngBtn = document.getElementById('pngBtn');
	jpgSizeSpan = document.getElementById('jpgSize');
	pngSizeSpan = document.getElementById('pngSize');


	stitchTools = document.getElementById("allStitchTools");
	cropTools = document.getElementById("allCropTools");
	textTools = document.getElementById("allTextTools");
	downloadTools = document.getElementById("downloadTools");
	dimensionsBox = document.getElementById("dimensionsBox");

	imageCanvas = document.getElementById('imageCanvas');
	ctx = imageCanvas.getContext('2d'); // Context for drawing on the canvas
	viewport = document.getElementById('viewport');
	cropCanvas = document.getElementById('cropCanvas');
	cropCtx = cropCanvas.getContext('2d');

	/////////////////////////////////////////////////////////
	//      Change HTML elements to match user vars        //
	/////////////////////////////////////////////////////////
console.log("%c[SETUP] Applying initial UI states...", "color: blue");
	transparencySlider.value = (1 - confOpacity) * 100;
	updateTransparency411(transparencySlider.value);
	if (confirmBeforeStitch !== null) { 
	    confirmCheckbox.checked = confirmBeforeStitch;
	}
	cropColorInput.value = cropLineColor;
	populateBorderSize();
	populateFontType();
	borderColorInput.value = imageBgColor;
	textColorInput.value = textAppendColor;

    if (currentAppendLayout === "standard") {
        standardLayoutDiv.style.display = 'block';
        customLayoutDiv.style.display = 'none';
    } else {
        standardLayoutDiv.style.display = 'none';
        customLayoutDiv.style.display = 'block';
    }
	
    populateRegionDropdown();
    populateNewspaperDropdown(true); // Populate dropdown, skip preview on load
    if (stdNewsVar !== "") {
        stdNewsInput.value = stdNewsVar; // Set input box to user-defined default
    } else {
        stdNewsVar = stdNewsDrop.value; // Set default to the first available newspaper
    }
	stdDateInput.value = stdDateVar;
	stdPageInput.value = stdPageVar;
	stdItalicsBtn.classList.toggle("active", stdItalicsVar);
	stdNewsInput.style.fontStyle = stdItalicsVar ? "italic" : "normal";
	stdFontSizeDiv.innerText = stdFontSizeVar;

	if (stdAutoFitEnabled) {
	    stdFontIncBtn.classList.add("disabled");
	    stdFontDecBtn.classList.add("disabled");
	    stdAutoFitChk.checked = true;
	} else {
	    stdFontIncBtn.classList.remove("disabled");
	    stdFontDecBtn.classList.remove("disabled");
	    stdAutoFitChk.checked = false;
	}

	// set html for all custom elements
	for (let i = 1; i <= 5; i++) {
		const textBox = document.getElementById(`customText${i}`);
	
		textBox.value = customText[i - 1];
		textBox.style.fontStyle = customItalic[i - 1] ? "italic" : "normal"; // Italic
		textBox.style.fontWeight = customBold[i - 1] ? "bold" : "normal"; // &#55357;&#56613; Bold
		textBox.style.textAlign = customAlignment[i - 1]; // &#55357;&#56613; Justification
	
		document.getElementById(`custFontSize${i}`).innerText = customFontSizes[i - 1];
		document.getElementById(`AutoFit${i}`).checked = autoFitEnabled[i - 1];
		const fontInc = document.getElementById(`customFontInc${i}`);
		const fontDec = document.getElementById(`customFontDec${i}`);
	
		if (autoFitEnabled[i - 1]) {
			fontInc.classList.add("disabled");
			fontDec.classList.add("disabled");
		} else {
			fontInc.classList.remove("disabled");
			fontDec.classList.remove("disabled");
		}
	
		document.getElementById(`customBold${i}`).classList.toggle("active", customBold[i - 1]);
		document.getElementById(`customItalic${i}`).classList.toggle("active", customItalic[i - 1]);
		document.getElementById(`customAlignLeft${i}`).classList.toggle("active", customAlignment[i - 1] === "left");
		document.getElementById(`customAlignCenter${i}`).classList.toggle("active", customAlignment[i - 1] === "center");
		document.getElementById(`customAlignRight${i}`).classList.toggle("active", customAlignment[i - 1] === "right");
		document.getElementById(`customLine${i}Toggle`).checked = customLinesEnabled[i - 1];
		document.getElementById(`customOverlay${i}`).style.display = customLinesEnabled[i - 1] ? "none" : "block";
	
		document.getElementById(`customLine${i}Toggle`).addEventListener("change", function () {
			toggleCustomLine(i, this.checked);
		});
	} // end set custom ele's

	// no tab stops on custom buttons or checkboxes
	document.querySelectorAll(".no-tab").forEach(button => {
		button.setAttribute("tabindex", "-1");
	});
	document.querySelectorAll(".toggle-button").forEach(button => {
		button.setAttribute("tabindex", "-1");
	});

	/////////////////////////////////////////////////////////
	//                  Set listeners                      //
	/////////////////////////////////////////////////////////
console.log("%c[SETUP] Attaching event listeners...", "color: blue");
	doneButton.addEventListener("click", handleDoneClick);
	nextButton.addEventListener('click', stitchImages);
	transparencySlider.addEventListener('input', function() {
		confOpacity = 1 - (transparencySlider.value / 100);   // Update opacity based on slider value
		updateTransparency411(transparencySlider.value);    // Update the transparency display 
		updateCanvas();
	});
	nudgeU.addEventListener('click', () => handleNudge('U'));
	nudgeD.addEventListener('click', () => handleNudge('D'));
	nudgeL.addEventListener('click', () => handleNudge('L'));
	nudgeR.addEventListener('click', () => handleNudge('R'));
	cropCanvas.addEventListener('mousedown', handleMouseDown);
	cropCanvas.addEventListener('mousemove', handleMouseMove);
	cropCanvas.addEventListener('mouseup', handleMouseUp);

	document.getElementById('CropOn').addEventListener('click', () => cropCanvas.style.display = "block");
	document.getElementById('CropOff').addEventListener('click', () => cropCanvas.style.display = "none");

	cropColorInput.addEventListener("change", function() {
		cropLineColor = this.value;
		drawCropLines();
		addShade();
	});
	document.getElementById('RotL01.00').addEventListener('click', function() { RotateImg( -1.00) ;});
	document.getElementById('RotR01.00').addEventListener('click', function() { RotateImg(  1.00) ;});
	document.getElementById('RotL00.10').addEventListener('click', function() { RotateImg(  -.10) ;});
	document.getElementById('RotR00.10').addEventListener('click', function() { RotateImg(   .10) ;});
	document.getElementById('RotL00.01').addEventListener('click', function() { RotateImg( -0.01) ;});
	document.getElementById('RotR00.01').addEventListener('click', function() { RotateImg(  0.01) ;});

	borderSizeSelect.addEventListener('change', function() {
		borderSize = parseInt(this.value, 10); // Update user var
		updateLivePreview("Border Size"); // &#55357;&#56613; Placeholder for live preview update
	});
	fontTypeSelect.addEventListener('change', function() {
		selectedFont = this.value; // Update user var
		updateLivePreview(); // &#55357;&#56613; Placeholder for live preview update
	});
	borderColorInput.addEventListener("change", function() {
	    imageBgColor = this.value;
	    updateLivePreview("BorderColor");
	});
	textColorInput.addEventListener("change", function() {
	    textAppendColor = this.value;
	    updateLivePreview("Text Color");
	});

	document.querySelectorAll('input[name="appendLayout"]').forEach(radio => {
		if (radio.value === currentAppendLayout) {
			radio.checked = true;
		}
		// Add event listener for layout change
		radio.addEventListener('change', function() {
			currentAppendLayout = this.value;
			if (currentAppendLayout === "standard") {
				standardLayoutDiv.style.display = 'block';
				customLayoutDiv.style.display = 'none';
			} else {
				standardLayoutDiv.style.display = 'none';
				customLayoutDiv.style.display = 'block';
			}
			updateLivePreview(currentAppendLayout);
		});
	});

	stdNewsInput.addEventListener("change", function() {
		stdNewsVar = this.value;
		updateLivePreview(stdNewsVar);
	});
	stdDateInput.addEventListener("change", function() {
		stdDateVar = this.value;
		updateLivePreview(stdDateVar);
	});
	stdPageInput.addEventListener("input", function () {
		if (this.value.length > this.maxLength) {
			this.value = this.value.slice(0, this.maxLength);
		}
		stdPageVar = stdPageInput.value;
		updateLivePreview(stdPageVar);
	});
	stdItalicsBtn.addEventListener("click", toggleStandardItalic);

	stdFontIncBtn.addEventListener("click", function() {
		let currentSize = parseInt(stdFontSizeDiv.innerText, 10);
		if (currentSize < maxFontSize) { // Max limit
			let newSize = currentSize + 1;
			stdFontSizeDiv.innerText = newSize;
			stdFontSizeVar = newSize;
		}
		updateLivePreview("uLP - Font Size Up", stdFontSizeVar); // &#55357;&#56613; Placeholder for future function
	});

	stdFontDecBtn.addEventListener("click", function() {
		let currentSize = parseInt(stdFontSizeDiv.innerText, 10);
		if (currentSize > minFontSize) { // Min limit
			let newSize = currentSize - 1;
			stdFontSizeDiv.innerText = newSize;
			stdFontSizeVar = newSize;
		}
		updateLivePreview("uLP - Font Size Dn", stdFontSizeVar); // &#55357;&#56613; Placeholder for future function
	});

	stdAutoFitChk.addEventListener("change", function() {
		stdAutoFitEnabled = this.checked;
		if (stdAutoFitEnabled) {
			stdFontIncBtn.classList.add("disabled");
			stdFontDecBtn.classList.add("disabled");
			updateLivePreview("uLP - AutoFit"); // &#55357;&#56613; Only update if changing from NOT CHECKED to CHECKED
		} else {
			stdFontIncBtn.classList.remove("disabled");
			stdFontDecBtn.classList.remove("disabled");
		}
	});

	// Attach event listener to all date buttons
	document.querySelectorAll(".date-btn").forEach(button => {
		button.addEventListener("click", handleDateClick);
	});

	document.querySelectorAll('[data-group="page-text"]').forEach(button => {
		button.addEventListener("click", handlePageClick);
	});

// Attach event listeners for all custom text controls
for (let i = 1; i <= 5; i++) {
	let custTextInput = document.getElementById(`customText${i}`);

	// &#55357;&#56608; Font Size Up / Down
	["Inc", "Dec"].forEach(dir => {
		document.getElementById(`customFont${dir}${i}`).addEventListener("click", function () {
			if (!autoFitEnabled[i - 1]) {
				let change = dir === "Inc" ? 1 : -1;
				let newSize = customFontSizes[i - 1] + change;
				if (newSize >= minFontSize && newSize <= maxFontSize) { // Ensure within range
					customFontSizes[i - 1] = newSize;
					document.getElementById(`custFontSize${i}`).textContent = newSize;
                    
					updateLivePreview("Font Size"); // &#55357;&#56613; Placeholder for live preview update
				}
			}
		});
	});

	// &#55357;&#57056;&#65039; AutoFit Toggle
	document.getElementById(`AutoFit${i}`).addEventListener("change", function () {
		autoFitEnabled[i - 1] = this.checked;
		let incBtn = document.getElementById(`customFontInc${i}`);
		let decBtn = document.getElementById(`customFontDec${i}`);

		if (this.checked) {
			incBtn.classList.add("disabled");
			decBtn.classList.add("disabled");
			updateLivePreview("uLP - AutoFit"); // Only trigger when turning ON
		} else {
			incBtn.classList.remove("disabled");
			decBtn.classList.remove("disabled");
		}
	});

	// &#55357;&#56541; Text Input Listener
	custTextInput.addEventListener("change", function () {
		customText[i - 1] = this.value.trim(); // Store text, remove leading/trailing spaces
		updateLivePreview("Custom Text"); // &#55357;&#56613; Call the preview update
	});

	// &#55357;&#56609; Bold Button Listener
	let boldBtn = document.getElementById(`customBold${i}`);
	boldBtn.addEventListener("click", function () {
		customBold[i - 1] = !customBold[i - 1];  // Toggle Bold
		custTextInput.style.fontWeight = customBold[i - 1] ? "bold" : "normal"; // Adjust based on new state
		this.classList.toggle("active", customBold[i - 1]); // Toggle button active state

		updateLivePreview("Cust Bold"); // &#55357;&#56613; Placeholder for live preview update
	});

	// &#55357;&#56608; Italic Button Listener
	let italicBtn = document.getElementById(`customItalic${i}`);
	italicBtn.addEventListener("click", function () {
		customItalic[i - 1] = !customItalic[i - 1];  // Toggle Italic
		custTextInput.style.fontStyle = customItalic[i - 1] ? "italic" : "normal"; // Adjust based on new state
		this.classList.toggle("active", customItalic[i - 1]); // Toggle button active state

		updateLivePreview("Cust Italics"); // &#55357;&#56613; Placeholder for live preview update
	});

	// &#55357;&#56527; Alignment Buttons Listener (L, C, R)
	const alignButtons = document.querySelectorAll(`[data-group="customAlign${i}"]`);
	alignButtons.forEach(button => {
		button.addEventListener("click", function () {
			customAlignment[i - 1] = this.getAttribute("data-value"); // Set alignment
			custTextInput.style.textAlign = customAlignment[i - 1]; // Apply alignment
			alignButtons.forEach(btn => btn.classList.remove("active"));
			this.classList.add("active");
			updateLivePreview("Cust Justify");
		});
	});
} // End Attach event listeners 1-5

jpgBtn.addEventListener("click", () => downloadImage("jpg"));
pngBtn.addEventListener("click", () => downloadImage("png"));

document.getElementById("George").addEventListener("click", () => {
	dlFilename.value = "";
	location.reload();
});


	/////////////////////////////////////////////////////////
	//                Initialize Startup                   //
	/////////////////////////////////////////////////////////

	stitchTools.style.display = "block";   // Always starts visible
	cropTools.style.display = "none";      // Hidden until needed
	textTools.style.display = "none";      // Hidden until needed
	downloadTools.style.display = "none";  // Hidden until needed
	dimensionsBox.style.display = "block"; // Always starts visible

	confirmControlsActive(false);
	doneButton.disabled = false; // in case no stitch required
	zoomButton.disabled = true;
	canPaste(true); // Turn on PASTE ability
	updateStatus411("Waiting for TImg...");
	console.log("%c[READY] Init. complete. Waiting for user...", "color: green");

}; // END WINDOW.ONLOAD

/////////////////////////////////////////////////////////
//                                                     //
//  Sect. 2 - USER ACTIONS (PASTING & PROCESSING)      //
//                                                     //
/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
//            FUNCTION - toggle paste listener         //
/////////////////////////////////////////////////////////
function canPaste(allowPaste) {
	if (allowPaste && !pasteListenerActive) {
		// Enable paste listener
		document.addEventListener('paste', handleImagePaste);
		pasteListenerActive = true; // Update the flag
	} else if (!allowPaste && pasteListenerActive) {
		// Disable paste listener
		document.removeEventListener('paste', handleImagePaste);
		pasteListenerActive = false; // Update the flag
	}
}

/////////////////////////////////////////////////////////
//      ASYNC FUNCTION - handleImagePaste              //
/////////////////////////////////////////////////////////
async function handleImagePaste(event) {
	let confirmIsGo = confirmCheckbox.checked;  // Get the checked state of the checkbox
	if (imgCount === 0) {
		await processFirstImage(event);  // Wait for the first image to finish processing
		await drawSearchBox(); // visual of search area
		confirmCheckbox.disabled = true;  // Disable the checkbox
	} else {
		await processSecondImage(event);  // Wait for the second image to finish processing
		await getSnippetFromBImg();  // Only after BImg is ready, we get the snippet
		await compare();
		if (isValidated) {
			await calcOffsets();
			if (confirmIsGo) {
				console.log("Confirm Is GO!");
				updateStatus411("Awaiting confirmation...");
				confirmControlsActive(true);  // Enable the ConfirmControls
				updateCanvas();
			} else {
				stitchImages();
			}
		}
		isValidated = false;
	}
} // end handleImagePaste

/////////////////////////////////////////////////////////
//      ASYNC FUNCTION - HANDLE TImg PASTE             //
/////////////////////////////////////////////////////////
async function processFirstImage(event) {
	await processImage(event, 'TImg'); // Process TImg (first image)
	imgCount++;
	updateImgCount411(1);
	updateStatus411("Waiting for BImg...");
}

/////////////////////////////////////////////////////////
//      ASYNC FUNCTION - HANDLE BImg PASTE             //
/////////////////////////////////////////////////////////
async function processSecondImage(event) {
	await processImage(event, 'BImg'); // Process BImg (second image)
	imgCount++;
	updateImgCount411(imgCount);
}

/////////////////////////////////////////////////////////
//      ASYNC FUNCTION - PROCESS IMAGES ONTO CANVAS    //
/////////////////////////////////////////////////////////
async function processImage(event, imageType) {
	// Load image asynchronously
	const img = await loadImage(event); 
  
	// Handle canvas resizing and drawing
	if (imageType === 'TImg') {
		// First image (TImg) handling
		imageCanvas.width = img.naturalWidth + (dispPadding * 2);  // Resize canvas for TImg
		imageCanvas.height = img.naturalHeight;     // Height same as the image
		matchStyleToCanvas();  // Update canvas size
		updateCanvasSize411(`${imageCanvas.width}x${imageCanvas.height}`);

		// Clear canvas and draw TImg
		ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height); 
		ctx.drawImage(img, dispPadding, 0);  // Draw TImg centered at (dispPadding, 0)

		// Update 411 status for TImg
		updateTImgLoc411(`${dispPadding},0`);
		updateTImgSize411(`${img.naturalWidth}x${img.naturalHeight}`);

		TImg = img;

	} else if (imageType === 'BImg') {
		// Second image (BImg) handling
		imageCanvas.width = Math.max(TImg.naturalWidth, img.naturalWidth) + (dispPadding * 2); // Set canv W to the lrgst img W
		imageCanvas.height = TImg.naturalHeight + img.naturalHeight + 10;   // Set canvas height to both images' height + 10
		matchStyleToCanvas(); // Update canvas size
		updateCanvasSize411(`${imageCanvas.width}x${imageCanvas.height}`);
		updateBImgSize411(`${img.naturalWidth}x${img.naturalHeight}`);

		// Clear canvas and draw both images
		ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
		ctx.drawImage(TImg, dispPadding, 0);  // Draw TImg at (dispPadding, 0)
		ctx.drawImage(img, dispPadding, TImg.naturalHeight + 10);  // Draw BImg below TImg

		// Update 411 status for BImg
		updateTImgLoc411(`${dispPadding},0`);
		updateBImgPrevLoc411(`${dispPadding}, ${TImg.naturalHeight + 10}`);

		BImg = img;
	}
}

/////////////////////////////////////////////////////////
//      ASYNC FUNCTION - loadImage INTO SYS FOR USE    //
/////////////////////////////////////////////////////////
async function loadImage(event) {
	return new Promise((resolve, reject) => {
		const clipboardData = event.clipboardData;
		const items = clipboardData.items;
    
		for (let i = 0; i < items.length; i++) {
			if (items[i].type.indexOf('image') !== -1) {
				const blob = items[i].getAsFile();
				const reader = new FileReader();

				reader.onload = function(e) {
					const img = new Image();
					img.onload = function() {
					resolve(img);  // Resolve the promise with the loaded image
					};
					img.src = e.target.result;
				};
				reader.readAsDataURL(blob);
			}
		}
	});
}

/////////////////////////////////////////////////////////
//      ASYNC FUNCTION - GET SNIPPET - BIMG            //
/////////////////////////////////////////////////////////
async function getSnippetFromBImg() {
	updateStatus411("<i>Obtaining BImg snippet...</i>");
    
	// Get the width of BImg and calculate the snippet width
	const snippetWidth = Math.round(Math.min(BImg.naturalWidth, TImg.naturalWidth) * snippetWidthPercentage);  // 50% of sm. w
	const snippetHeight = 1;  // Always 1px high
	const startX = Math.round((BImg.naturalWidth - snippetWidth) / 2);  // Center the snippet horizontally
	const startY = 0;  // The snippet is always from row 1 (top row)

	// Create a canvas to extract the snippet from BImg
	const snippetCanvas = document.createElement('canvas');
	const snippetCtx = snippetCanvas.getContext('2d');

	// Set the snippet canvas dimensions
	snippetCanvas.width = snippetWidth;
	snippetCanvas.height = snippetHeight;

	// Draw the snippet from BImg onto the snippetCanvas
	snippetCtx.drawImage(BImg, startX, startY, snippetWidth, snippetHeight, 0, 0, snippetWidth, snippetHeight);

	// Get the image data from the snippet
	const snippetData = snippetCtx.getImageData(0, 0, snippetWidth, snippetHeight);

	// Convert the snippet data to greyscale and store it in a structured way
	const greyscaleSnippet = [];
	for (let i = 0; i < snippetData.data.length; i += 4) {
		// Calculate the greyscale value as the average of the RGB values
		const grey = Math.round(0.2126 * snippetData.data[i] + 0.7152 * snippetData.data[i + 1] + 0.0722 * snippetData.data[i + 2]);
		greyscaleSnippet.push(grey);  // Store only the greyscale value (R = G = B)
	}

	// Store the snippet data in a structured object
	BsnippetData = {
		width: snippetWidth,
		height: snippetHeight,
		data: greyscaleSnippet,  // Only greyscale values
		startX: startX,
		startY: startY
	};

	console.log(startX,startY);

	// Now, we need to extract the next 9 rows for BchunkData
	const chunkCanvas = document.createElement('canvas');
	const chunkCtx = chunkCanvas.getContext('2d');
	chunkCanvas.width = snippetWidth;  // Width of the chunk (same as snippet)
	chunkCanvas.height = chunkHeight - 1;  // Height for the 9 rows we're extracting

	// Draw the entire 9 rows at once onto the chunkCanvas
	chunkCtx.drawImage(BImg, startX, startY + snippetHeight, snippetWidth, chunkCanvas.height, 0, 0, snippetWidth, chunkCanvas.height);

	// Now get the image data for the 9 rows at once
	const chunkData = chunkCtx.getImageData(0, 0, snippetWidth, chunkCanvas.height);
	const greyscaleChunk = [];

	// Convert the image data to greyscale and store it in rows
	for (let row = 0; row < chunkCanvas.height; row++) {
		let rowPixels = [];
		for (let col = 0; col < snippetWidth; col++) {
			const i = (row * snippetWidth + col) * 4; // Index for RGBA data
			const grey = Math.round(0.2126 * chunkData.data[i] + 0.7152 * chunkData.data[i + 1] + 0.0722 * chunkData.data[i + 2]);
			rowPixels.push(grey);  // Add greyscale pixel to the row
		}
		greyscaleChunk.push(rowPixels);  // Add this row to the chunk data
	}

	// Store the chunk data in a structured object
	BchunkData = {
		data: greyscaleChunk  // Array of 9 rows
	};
} // end getSnippetFromBImg

/////////////////////////////////////////////////////////
//      ASYNC FUNCTION - GET SNIPPET - TIMG            //
/////////////////////////////////////////////////////////
async function getSnippetFromTImg(x, y, width) {
	return new Promise((resolve, reject) => {
		// Create a temporary canvas to extract the snippet from TImg
		const canvas = document.createElement('canvas');
		const ctx = canvas.getContext('2d');

		// Set canvas size to the snippet's width (and a height of 1px)
		canvas.width = width;
		canvas.height = 1;

		// Draw the snippet from TImg on the canvas
		ctx.drawImage(TImg, x, y, width, 1, 0, 0, width, 1);

		// Get the pixel data from the snippet
		const snippetData = ctx.getImageData(0, 0, width, 1).data;

		// Convert the pixel data to grayscale and return the result
		const greyscaleSnippet = [];
		for (let i = 0; i < snippetData.length; i += 4) {
			// Calculate the grayscale value (average of RGB)
			const grey = Math.round(0.2126 * snippetData[i] + 0.7152 * snippetData[i + 1] + 0.0722 * snippetData[i + 2]);
			greyscaleSnippet.push(grey);  // Only store grayscale values (R = G = B)
		}
		resolve(greyscaleSnippet); // Return the snippet data when ready
	});
}

/////////////////////////////////////////////////////////
//      ASYNC FUNCTION - GET CHUNK - TIMG              //
/////////////////////////////////////////////////////////
async function getChunkFromTImg(x, y, chunkWidth, chunkHeight) {
    return new Promise((resolve, reject) => {
        // Create a temporary canvas to extract the chunk
        const canvasTemp = document.createElement('canvas');
        const ctxTemp = canvasTemp.getContext('2d');

        // Set the canvas size to the chunk size
        canvasTemp.width = chunkWidth;
        canvasTemp.height = chunkHeight;

        // Wait for the image (TImg) to be loaded before drawing the chunk
        TImg.onload = function() {
            try {
                // Draw the specified chunk of TImg onto the temporary canvas
                ctxTemp.drawImage(TImg, x, y, chunkWidth, chunkHeight, 0, 0, chunkWidth, chunkHeight);

                // Get the pixel data from the temporary canvas
                const imageData = ctxTemp.getImageData(0, 0, chunkWidth, chunkHeight);
                const pixelData = [];

                // Convert the image data to greyscale and store it in rows
                for (let row = 0; row < chunkHeight; row++) {
                    let rowPixels = [];
                    for (let col = 0; col < chunkWidth; col++) {
                        const i = (row * chunkWidth + col) * 4; // Index for RGBA data
                        const grey = Math.round(0.2126 * imageData.data[i] + 0.7152 * imageData.data[i + 1] + 0.0722 * imageData.data[i + 2]);
                        rowPixels.push(grey);  // Add greyscale pixel to the row
                    }
                    pixelData.push(rowPixels);  // Add the row of pixels to the chunk data
                }

                // Resolve the promise with the 2D pixel data
                resolve(pixelData);
            } catch (error) {
                reject(error);  // Reject the promise if there is an error
            }
        };

        // Trigger the loading of the image if it's not already loaded
        if (TImg.complete) {
            TImg.onload();
        }
    });
}

/////////////////////////////////////////////////////////
//      ASYNC FUNCTION - DRAW & DEFINE SEARCH BOX      //
/////////////////////////////////////////////////////////
async function drawSearchBox(extra) {
	// Calculate the dimensions for the search area
	const searchWidth = Math.round(searchWidthPercentage * TImg.naturalWidth);  // 90% of TImg width, rounded

	// Calculate the starting point to center the search box horizontally for display (shifted 100px to the right)
	const startX = Math.round((TImg.naturalWidth - searchWidth) / 2) + dispPadding; // Shifted by 100px for display
	const startY = Math.round(TImg.naturalHeight - searchHeight - chunkHeight); // Starting 60px from the bottom for display

	// Store these values for the actual search area (no +100 for actual search)
	searchArea = {
		width: searchWidth,
		height: searchHeight,
		startX: Math.round((TImg.naturalWidth - searchWidth) / 2), 
		startY: Math.round(TImg.naturalHeight - searchHeight - chunkHeight) 
	};

	// Draw the search area box on the canvas (display purpose)
	ctx.beginPath();
	ctx.setLineDash([5, 5]); // Dashed lines
	ctx.lineWidth = 2; // 2px line thickness
	ctx.strokeStyle = 'red'; // Red color for the box

	// Draw the rectangle (search area box for display)
	ctx.rect(startX, startY, searchWidth, searchHeight);
	ctx.stroke(); // Apply the drawing

	// Optionally, log the values for verification
  console.log('Search Area: ', searchArea);

	if (extra === "plusLine") {
		// Set up the flashing line
		let colorIndex = 0;
		const colors = ['red', 'white']; // Flashing colors

		// Flashing interval (change the color every 250ms)
		setInterval(() => {
			ctx.setLineDash([]); // Solid line
			ctx.strokeStyle = colors[colorIndex]; // Use the current color
			ctx.lineWidth = 2; // Line width

			// Begin drawing the line
			ctx.beginPath();
			ctx.moveTo(BsnippetData.startX + dispPadding, TImg.naturalHeight + 10); // Starting point
			ctx.lineTo(BsnippetData.startX + BsnippetData.width + dispPadding, TImg.naturalHeight + 10); // Ending point
			ctx.stroke(); // Actually draw the line

			// Cycle through colors
			colorIndex = (colorIndex + 1) % colors.length;
		}, 500); // Flash every 250ms (quarter a second)
	} // end if plusline
} // end drawSearchBox

/////////////////////////////////////////////////////////
//            FUNCTION - SCROLL TO BOTTOM              //
/////////////////////////////////////////////////////////
function scrollToBottom() {
	const viewportHeight = viewport.clientHeight;
	const canvasHeight = imageCanvas.height;

	// Scroll the viewport to the bottom of the canvas
	viewport.scrollTop = canvasHeight - viewportHeight + 60;
}


/////////////////////////////////////////////////////////
//                                                     //
//  Sect. 3 - CONFIRMATION (can be skipped via user)   //
//                                                     //
/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
//            FUNCTION - handleNudge                   //
/////////////////////////////////////////////////////////
function handleNudge(direction) {
	if (direction === 'U') { adjustedBImgY -= 1; VOffset -= 1; }
	else if (direction === 'D') { adjustedBImgY += 1; VOffset += 1; }
	else if (direction === 'L') { adjustedBImgX -= 1; HOffset -= 1; }
	else if (direction === 'R') { adjustedBImgX += 1; HOffset += 1; }
	updateCanvas();
} // end handleNudge

/////////////////////////////////////////////////////////
//            FUNCTION - updateCanvas                  //
/////////////////////////////////////////////////////////
function updateCanvas() {
	ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
	ctx.globalAlpha = 1;
	ctx.drawImage(TImg, dispPadding, 0);
	ctx.globalAlpha = confOpacity;
	ctx.drawImage(BImg, adjustedBImgX, adjustedBImgY);

	// Update UI elements (for transparency, offset, etc.)
	updateBImgPostLoc411(`${adjustedBImgX}, ${adjustedBImgY}`);
	updateHOffset411(HOffset);
	updateVOffset411(VOffset);
} // end updateCanvas

/////////////////////////////////////////////////////////
//            FUNCTION - Confirmation Controls Toggle  //
/////////////////////////////////////////////////////////
function confirmControlsActive(isActive) {
	// Enable/disable the slider and NEXT button
	transparencySlider.disabled = !isActive;
	nextButton.disabled = !isActive;

	// Add or remove the 'disabled' class for nudge buttons
	if (isActive) {
		nudgeU.classList.remove('disabled');
		nudgeL.classList.remove('disabled');
		nudgeR.classList.remove('disabled');
		nudgeD.classList.remove('disabled');
	} else {
		nudgeU.classList.add('disabled');
		nudgeL.classList.add('disabled');
		nudgeR.classList.add('disabled');
		nudgeD.classList.add('disabled');
	}
	console.log(`Conf Controls are now ${isActive ? 'enabled' : 'disabled'}`);
}

/////////////////////////////////////////////////////////
//      ASYNC FUNCTION - OVERLAY BImg on TImg          //
/////////////////////////////////////////////////////////
async function calcOffsets() {
	adjustedBImgX = dispPadding + (TImgSS.startX - BsnippetData.startX); // Shift left OR right
	HOffset = TImgSS.startX - BsnippetData.startX;
	adjustedBImgY = TImgSS.startY - BsnippetData.startY; // Adjust for Y-axis

	// Draw BImg at its adjusted position
	console.log(`Overlay B at: ${adjustedBImgX}, ${adjustedBImgY}`);
	VOffset = TImgSS.startY - TImg.naturalHeight;
	updateBImgPostLoc411(`${adjustedBImgX}, ${adjustedBImgY}`);
	updateHOffset411(HOffset);
	updateVOffset411(VOffset);
}

/////////////////////////////////////////////////////////
//                                                     //
//  Sect. 4 - STITCH FUNCTIONS                         //
//                                                     //
/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
//      ASYNC FUNCTION - COMPARE                       //
/////////////////////////////////////////////////////////
async function compare() {
	updateStatus411("Comparing...");
	console.log('Comparing...');
	const comparesPerLine = Math.floor(searchArea.width - BsnippetData.width);  // Number of comparisons per line
	let x = searchArea.startX;
	let y = searchArea.startY;
	let matchFound = false;
	let highestMatch = 0;
	let HighRowMatch = 0;
	let highRowMatchCoords = { x: 0, y: 0 };  // Store the coordinates of the highest match

	for (let row = 0; row < searchHeight; row++) {  // Use searchHeight for dynamic row count
		HighRowMatch = 0;  // Initialize the highest match score for the row
    
		for (let col = 0; col < comparesPerLine; col++) {
			// Await the snippet from TImg
			const snippet = await getSnippetFromTImg(x, y, BsnippetData.width); // Wait until the snippet is ready
			const matchScore = compareSnippets(snippet); // Compare snippet to BsnippetData with tolerance

			// If the current match score is higher than the highest for this row, update it
			if (matchScore > HighRowMatch) {
				HighRowMatch = matchScore;  // Update the highest match score for this row
				highRowMatchCoords = { x, y };  // Store the coordinates of the highest match
			}
			if (matchScore > highestMatch) {
				highestMatch = matchScore;
				highestMatchCoords = { x, y };
			}

			// If match score is > 95% and validation hasn't occurred yet
			if (matchScore > 95 && !isValidated) {
				console.log(`${matchScore.toFixed(2)}% at ${x},${y} ...`);
				updateSnip411(`<span class="goodMsg">${(Math.floor(matchScore * 100) / 100).toFixed(2)}%</span>`);
          
				await validate(x,y);  // Await validation, pause here until validation completes

				if (isValidated) {
					console.log('Validation passed! Exiting compare...');
					return;  // Exit compare once validated
				} else {
					console.log('Validation failed. Continuing comparison...');
				}
			}
			// Move 1px to the right for the next comparison
			x++;  
		}

		// After finishing a row, log the highest match score and its coordinates
		if (HighRowMatch > 50) {
			console.log(`Row ${row} - >50: ${HighRowMatch.toFixed(2)}% at coords (${highRowMatchCoords.x}, ${highRowMatchCoords.y})`);
		}

		// Reset x to the start of the next row
		x = searchArea.startX;
		y++;  // Move down a line
	}
	if (highestMatch > 95) {
		console.log(`Validation failed - highest match was ${highestMatch.toFixed(2)}%`);
		updateStatus411("<span class='errorMsg'>Vaidation FAILED.</span>");
		updateSnip411(`<span class="goodMsg">${highestMatch.toFixed(0)}% at (${highestMatchCoords.x}, ${highestMatchCoords.y})</span>`);
		await drawSearchBox("plusLine"); // visual of possible error
	} else {
		console.log(`Compare failed - highest match was ${highestMatch.toFixed(2)}%`);
		updateStatus411("<span class='errorMsg'>Compare FAILED.</span>");
		updateSnip411(`<span class='errorMsg'>${highestMatch.toFixed(0)}% at (${highestMatchCoords.x}, ${highestMatchCoords.y})</span>`);
		await drawSearchBox("plusLine"); // visual of possible error
	}

	console.log('Comparison complete.');
} // end compare

/////////////////////////////////////////////////////////
//            FUNCTION - compareSnippets               //
/////////////////////////////////////////////////////////
function compareSnippets(snippet) {
	const toleranceValue = Math.round(255 * matchTolerance);  // Use global matchTolerance
	let matchCount = 0;

	// Compare each pixel from the snippet with the corresponding pixel from BsnippetData.data
	for (let i = 0; i < snippet.length; i++) {
		// If the absolute difference between the pixels is within the tolerance, consider it a match
		if (Math.abs(snippet[i] - BsnippetData.data[i]) <= toleranceValue) {
			matchCount++;  // Increment the match count for this pixel
		}
	}

	// Calculate the match percentage
	const matchPercentage = (matchCount / snippet.length) * 100;
	return matchPercentage;
}

/////////////////////////////////////////////////////////
//      ASYNC FUNCTION - VALIDATE                      //
/////////////////////////////////////////////////////////
async function validate(x, y) {
	updateStatus411("Validating...");
	console.log('Validating...');
     let tempDiffCount = 0;
	const chunkWidth = BsnippetData.width;  // Get width from BsnippetData
	const chunkDataTImg = await getChunkFromTImg(x, y, chunkWidth, chunkHeight);  // Function to extract TImg chunk

	// Create a temporary copy of BchunkData to avoid modifying the global variable
	const tempBchunkData = { ...BchunkData };
	tempBchunkData.data.unshift(BsnippetData.data);  // Temporarily add row 1

	let toleranceMatchCount = 0;
	let exactMatchSum = 0;
	const totalPixels = chunkWidth * chunkHeight;

	// Compare TImg and BImg chunk pixel by pixel (using tempBchunkData)
	const toleranceValue = Math.round(255 * matchTolerance);  // Calculate the tolerance value using global matchTolerance
	for (let i = 0; i < chunkHeight; i++) {
		for (let j = 0; j < chunkWidth; j++) {
 			const pixelTImg = chunkDataTImg[i][j];
			const pixelBImg = tempBchunkData.data[i][j];  // Use the temporary chunk data

			// Skip invalid values (check pixel range)
 			if (typeof pixelTImg !== 'number' || typeof pixelBImg !== 'number') {
				console.error(`Invalid pixel values at (${i}, ${j}): TImg = ${pixelTImg}, BImg = ${pixelBImg}`);
				continue;  // Skip this pixel if the value is not a number
			}

			// Tolerance-based match
			const difference = Math.round(Math.abs(pixelTImg - pixelBImg));
			if (difference <= toleranceValue) {
				toleranceMatchCount++;
			}
			if (difference > 0) {
				tempDiffCount++;
			}

			// Exact match score
			const exactMatchPercentage = 100 - (difference / 255) * 100;  // Exact match score
			exactMatchSum += exactMatchPercentage;
		}
	}
	console.log(`Total Differences: ${tempDiffCount}`);

	// Calculate the tolerance-based match percentage
	const toleranceMatchPercentage = (toleranceMatchCount / totalPixels) * 100;

	// Calculate the average exact match percentage
	const exactMatchPercentage = exactMatchSum / totalPixels;

	// If tolerance match is >95%, set isValidated to true
	if (toleranceMatchPercentage > 95) {
		TImgSS.startX = x;
		TImgSS.startY = y;
		console.log(`TImgSS: ${x}, ${y}`);
          console.log(`BIngSS: ${BsnippetData.startX}, ${BsnippetData.startY}`);
		isValidated = true;
	}

    // Update the status with the match percentages
	updateChunk411(`<span class="goodMsg">${(Math.floor(exactMatchPercentage * 100) / 100).toFixed(2)}%</span>`);
	console.log(`ToleranceMatch: ${toleranceMatchPercentage}%`);
} // end validate

/////////////////////////////////////////////////////////
//            FUNCTION - stitchImages                  //
/////////////////////////////////////////////////////////
function stitchImages() {
	confirmControlsActive(false); // turn off ConfControls
	updateStatus411("Stitching...");

	// 1. Create the new canvas for the stitched image
	const stitchCanvas = document.createElement('canvas');
	const stitchCtx = stitchCanvas.getContext('2d');

	// 2. Set the canvas size based on the calculated width and height
	if (HOffset > 0) {
		stitchCanvas.width = Math.max(BImg.naturalWidth + HOffset, TImg.naturalWidth);  // Wider of BImg + offset or TImg width
	} else { // HOffset is negative
		stitchCanvas.width = Math.max(TImg.naturalWidth + Math.abs(HOffset), BImg.naturalWidth); // Wider of TImg + abs(offset) or BImg width
	}

	stitchCanvas.height = TImg.naturalHeight + BImg.naturalHeight + VOffset; // Sum of heights + vertical offset

	// 3. Draw TImg at the correct position
	if (HOffset > 0) {
		// If HOffset is positive, place TImg at (0, 0)
		stitchCtx.drawImage(TImg, 0, 0);
		console.log("Stitch TImg at 0,0");
	} else {
		// If HOffset is negative, move TImg right by the absolute value of HOffset
		stitchCtx.drawImage(TImg, Math.abs(HOffset), 0);
		console.log(`Stitch TImg at ${Math.abs(HOffset)}, 0`);
	}

	// 4. Draw BImg at its adjusted position (adjustedBImgX, adjustedBImgY)
	if (HOffset > 0){
		// stitchCtx.drawImage(BImg, dispPadding - adjustedBImgX, adjustedBImgY); // ended up negative (offcscreen)
		stitchCtx.drawImage(BImg, adjustedBImgX - dispPadding, adjustedBImgY); // works now
		console.log(`Stitch BImg at ${adjustedBImgX - dispPadding}, ${adjustedBImgY}`);
	} else {
		stitchCtx.drawImage(BImg, 0, adjustedBImgY);
		console.log(`Stitch BImg at 0,${adjustedBImgY}`);
	}

	// 5. Set the stitched canvas as the new TImg
	TImg = new Image();
	TImg.src = stitchCanvas.toDataURL(); // Set new TImg to stitched image data

	// Once TImg is loaded, proceed to update the imageCanvas
	TImg.onload = function() {
		// 6. Use the correct canvas (imageCanvas) and adjust its size
		imageCanvas.width = TImg.naturalWidth + (dispPadding * 2);  // Make canvas width 200px larger than TImg width
		imageCanvas.height = TImg.naturalHeight;

		matchStyleToCanvas();

		ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);  // Clear the canvas

		// 7. Draw the new TImg at (0, dispPadding) on the imageCanvas
		ctx.drawImage(TImg, dispPadding, 0);  // Place the stitched TImg at (0, dispPadding)
		updateTImgLoc411(`0, ${dispPadding}`);
		updateBImgPrevLoc411("<i>n/a</i>");
		updateBImgPostLoc411("<i>n/a</i>");
		updateHOffset411("<i>n/a</i>");
		updateVOffset411("<i>n/a</i>");
		updateCanvasSize411(`${imageCanvas.width}x${imageCanvas.height}`);
		updateTImgSize411(`${TImg.naturalWidth}x${TImg.naturalHeight}`);
		updateBImgSize411("<i>n/a</i>");
		updateStatus411("Awaiting BImg or Done");
		doneButton.disabled = false;
		setTimeout(() => {
			drawSearchBox();  // Ensure this runs after the drawing is done
		}, 0);

		scrollToBottom();
		console.log('Canvas Height:', imageCanvas.height);
		console.log('Viewport Height:', viewport.clientHeight);
		console.log('Viewport Scroll Position:', viewport.scrollTop);
	};
} // end stitchImages


/////////////////////////////////////////////////////////
//                                                     //
//  Sect. 5 - CROP & ROTATE                            //
//                                                     //
/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
//            FUNCTION - Initiate Crop Lines           //
/////////////////////////////////////////////////////////
function initiateCropLines() {
	// Refresh CropLinesPos in case canvas size changed
	CropLinesPos = {
		...CropLinesPos,  // Keep the existing values (lineWidth, color)
		l: Math.round(dispPadding / 2),  // Left position
		r: imageCanvas.width - Math.round(dispPadding / 2),  // Right position
		t: Math.round(dispPadding / 2),  // Top position
		b: imageCanvas.height - Math.round(dispPadding / 2)  // Bottom position
	};

	// Set the cropCanvas dimensions based on imageCanvas
	cropCanvas.width = imageCanvas.width;
	cropCanvas.height = imageCanvas.height;

	// Clear the canvas before drawing new lines
	cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
    
	// Start a new path for drawing
	cropCtx.beginPath();
	cropCtx.strokeStyle = cropLineColor;
	cropCtx.lineWidth = cropLineWidth;

	// Left crop line
	cropCtx.moveTo(CropLinesPos.l, 0); // Start from top
	cropCtx.lineTo(CropLinesPos.l, imageCanvas.height); // Extend to bottom

	// Right crop line
	cropCtx.moveTo(CropLinesPos.r, 0); // Start from top
	cropCtx.lineTo(CropLinesPos.r, imageCanvas.height); // Extend to bottom

	// Top crop line
	cropCtx.moveTo(0, CropLinesPos.t); // Start from left
	cropCtx.lineTo(imageCanvas.width, CropLinesPos.t); // Extend to right

	// Bottom crop line
	cropCtx.moveTo(0, CropLinesPos.b); // Start from left
	cropCtx.lineTo(imageCanvas.width, CropLinesPos.b); // Extend to right

	// Draw the crop lines
	cropCtx.stroke();
}

/////////////////////////////////////////////////////////
//            FUNCTION - ADD SHADE TO CROP CANVAS      //
/////////////////////////////////////////////////////////
function addShade() {
	const red = parseInt(cropLineColor.slice(1, 3), 16);
	const green = parseInt(cropLineColor.slice(3, 5), 16);
	const blue = parseInt(cropLineColor.slice(5, 7), 16);

	cropCtx.fillStyle = `rgba(${red}, ${green}, ${blue}, ${cropOpacity})`;

	// Fill the entire canvas first
	cropCtx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);

	// Clear the area inside the crop lines using only CropLinesPos
	cropCtx.clearRect(CropLinesPos.l, CropLinesPos.t, 
                       CropLinesPos.r - CropLinesPos.l,  // width: right - left
                       CropLinesPos.b - CropLinesPos.t); // height: bottom - top
}

/////////////////////////////////////////////////////////
//            VARIABLES - Used for CROP functions      //
/////////////////////////////////////////////////////////
let isDraggingCropLine = false;
let draggedCropLine = null;
let cropStartX, cropStartY;

/////////////////////////////////////////////////////////
//            FUNCTION - Handle MouseDown CROP         //
/////////////////////////////////////////////////////////
function handleMouseDown(e) {
	const mouseX = e.offsetX;
	const mouseY = e.offsetY;

	// Check if the mouse is near a crop line (within a threshold) and set the dragged line
	if (Math.abs(mouseX - CropLinesPos.l) < 10) {
		draggedCropLine = 'l';
		cropStartX = mouseX;
		cropStartY = mouseY;
		isDraggingCropLine = true;
	} else if (Math.abs(mouseX - CropLinesPos.r) < 10) {
		draggedCropLine = 'r';
		cropStartX = mouseX;
		cropStartY = mouseY;
		isDraggingCropLine = true;
	} else if (Math.abs(mouseY - CropLinesPos.t) < 10) {
		draggedCropLine = 't';
		cropStartX = mouseX;
		cropStartY = mouseY;
		isDraggingCropLine = true;
	} else if (Math.abs(mouseY - CropLinesPos.b) < 10) {
		draggedCropLine = 'b';
		cropStartX = mouseX;
		cropStartY = mouseY;
		isDraggingCropLine = true;
	}
}

/////////////////////////////////////////////////////////
//            FUNCTION - Handle MouseDrag CROP         //
/////////////////////////////////////////////////////////
function handleMouseMove(e) {
	const mouseX = e.offsetX;
	const mouseY = e.offsetY;

	const tolerance = 10; // Distance to detect when mouse is near a line

	// Check if mouse is near the left or right crop line
	if (Math.abs(mouseX - CropLinesPos.l) < tolerance) {
		cropCanvas.style.cursor = "col-resize"; // Vertical resize cursor
	} else if (Math.abs(mouseX - CropLinesPos.r) < tolerance) {
		cropCanvas.style.cursor = "col-resize"; // Vertical resize cursor
	}
	// Check if mouse is near the top or bottom crop line
	else if (Math.abs(mouseY - CropLinesPos.t) < tolerance) {
		cropCanvas.style.cursor = "row-resize"; // Horizontal resize cursor
	} else if (Math.abs(mouseY - CropLinesPos.b) < tolerance) {
		cropCanvas.style.cursor = "row-resize"; // Horizontal resize cursor
	}
	// Reset cursor if not near any line
	else {
		cropCanvas.style.cursor = "default"; // Reset to default cursor
	}

	if (isDraggingCropLine && draggedCropLine) {
		const diffX = mouseX - cropStartX;
		const diffY = mouseY - cropStartY;

		// Update the position of the dragged crop line
		if (draggedCropLine === 'l' || draggedCropLine === 'r') {  // Use 'l' for left and 'r' for right
			CropLinesPos[draggedCropLine] += diffX;
		} else if (draggedCropLine === 't' || draggedCropLine === 'b') {  // Use 't' for top and 'b' for bottom
			CropLinesPos[draggedCropLine] += diffY;
		}

		// Redraw the crop lines with the updated position
		drawCropLines();

		// Update the start position for next move
		cropStartX = mouseX;
		cropStartY = mouseY;
	}
}

/////////////////////////////////////////////////////////
//            FUNCTION - DRAW CROP LINES               //
/////////////////////////////////////////////////////////
function drawCropLines() {
	// Clear the canvas before drawing new lines
	cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);

	// Start a new path for drawing
	cropCtx.beginPath();
	cropCtx.strokeStyle = cropLineColor;
	cropCtx.lineWidth = cropLineWidth;

	// Left crop line
	cropCtx.moveTo(CropLinesPos.l, 0); // Start from top
	cropCtx.lineTo(CropLinesPos.l, imageCanvas.height); // Extend to bottom

	// Right crop line
	cropCtx.moveTo(CropLinesPos.r, 0); // Start from top
	cropCtx.lineTo(CropLinesPos.r, imageCanvas.height); // Extend to bottom

	// Top crop line
	cropCtx.moveTo(0, CropLinesPos.t); // Start from left
	cropCtx.lineTo(imageCanvas.width, CropLinesPos.t); // Extend to right

	// Bottom crop line
	cropCtx.moveTo(0, CropLinesPos.b); // Start from left
	cropCtx.lineTo(imageCanvas.width, CropLinesPos.b); // Extend to right

	// Draw the crop lines
	cropCtx.stroke();
	addShade();
	let newCropW = CropLinesPos.r - CropLinesPos.l;
	let newCropH = CropLinesPos.b - CropLinesPos.t
	updateTImgSize411(`${newCropW}x${newCropH}`);
}

/////////////////////////////////////////////////////////
//            FUNCTION - Handle MouseUp CROP           //
/////////////////////////////////////////////////////////
function handleMouseUp() {
	isDraggingCropLine = false;
	draggedCropLine = null;
}

/////////////////////////////////////////////////////////
//            FUNCTION - ROTATE IMAGE                  //
/////////////////////////////////////////////////////////
function RotateImg(angle) {
	var NewAngle = CurrRotAngle + angle;
	NewAngle = Math.round(NewAngle * 100) / 100; // because sometimes you get 3.380000000000000000003...IDK why
	CurrRotAngle = NewAngle;

	let tempRotCanvas = document.createElement('canvas');
	let tempRotCtx = tempRotCanvas.getContext('2d');
	
	let angleInRadians = CurrRotAngle * Math.PI / 180;
	
	let rotatedWidth = Math.abs(TImg.width * Math.cos(angleInRadians)) + Math.abs(TImg.height * Math.sin(angleInRadians));
	let rotatedHeight = Math.abs(TImg.width * Math.sin(angleInRadians)) + Math.abs(TImg.height * Math.cos(angleInRadians));

	tempRotCanvas.width = rotatedWidth;
	tempRotCanvas.height = rotatedHeight;

	tempRotCtx.clearRect(0, 0, tempRotCanvas.width, tempRotCanvas.height);  // Clear canvas
	tempRotCtx.save();
	tempRotCtx.translate(rotatedWidth / 2, rotatedHeight / 2);  // Move to center of the temp canvas
	tempRotCtx.rotate(angleInRadians);  // Rotate the context
	tempRotCtx.drawImage(TImg, -TImg.width / 2, -TImg.height / 2);  // Draw image, centered

	let centerX = (imageCanvas.width - rotatedWidth) / 2;
	let centerY = (imageCanvas.height - rotatedHeight) / 2;

	ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height); // Clear the main canvas
	ctx.drawImage(tempRotCanvas, centerX, centerY);  // Draw the rotated image from temp canvas

	// Restore the context of the temporary canvas
	tempRotCtx.restore();

	console.log("Rotation: ", NewAngle);
	updateRot411(NewAngle);
};


/////////////////////////////////////////////////////////
//                                                     //
//  Sect. 6 - APPEND TEXT (placeholder)                //
//                                                     //
/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
//            VARIABLES - Used for Date Clicker Only   //
/////////////////////////////////////////////////////////
let clickedDateString = {
    "day-tens": "d",
    "day-ones": "d",
    "months": "Mmm",
    "centuries": "yy",
    "year-tens": "y",
    "year-ones": "y"
};
let skipDayTens = false; // Flag to track if day-tens is being skipped

/////////////////////////////////////////////////////////
//            FUNCTION - UPDATE DATE STRING (Standard) //
/////////////////////////////////////////////////////////
function updateDateString() {
	let dayTens = skipDayTens ? "" : clickedDateString["day-tens"];
	//const dateDisplay = document.getElementById("stdDateInput");

	stdDateInput.value = `${dayTens}${clickedDateString["day-ones"]} ${clickedDateString["months"]} ${clickedDateString["centuries"]}${clickedDateString["year-tens"]}${clickedDateString["year-ones"]}`;
	stdDateVar = `${dayTens}${clickedDateString["day-ones"]} ${clickedDateString["months"]} ${clickedDateString["centuries"]}${clickedDateString["year-tens"]}${clickedDateString["year-ones"]}`;

	// Run validation after updating the display
	validateDate();
}

/////////////////////////////////////////////////////////
//            FUNCTION - HANDLE Date Button Clicks     //
/////////////////////////////////////////////////////////
function handleDateClick(event) {
	const button = event.target;
	const group = button.getAttribute("data-group");
	const value = button.getAttribute("data-value");

	if (!group || !value) return; // Ignore clicks outside buttons

	// Special case for day-tens (the only optional one)
	if (group === "day-tens") {
		if (button.classList.contains("date-btn-active")) {
			// Clicking an active day-tens button turns it off
			button.classList.remove("date-btn-active");
			clickedDateString["day-tens"] = ""; // Remove day-tens
			skipDayTens = true; // Mark it as skipped
		} else {
			// Otherwise, activate day-tens normally
			skipDayTens = false; // Mark as not skipped
			document.querySelectorAll(".date-btn[data-group='day-tens']").forEach(btn => btn.classList.remove("date-btn-active"));
			button.classList.add("date-btn-active");
			clickedDateString["day-tens"] = value;
		}
	} else {
		// Normal behavior for all other groups
		document.querySelectorAll(`.date-btn[data-group='${group}']`).forEach(btn => btn.classList.remove("date-btn-active"));
		button.classList.add("date-btn-active");
		clickedDateString[group] = value;

		// If user clicks day-ones FIRST and day-tens is "d", assume skipDayTens = true
		if (group === "day-ones" && clickedDateString["day-tens"] === "d") {
			skipDayTens = true;
			clickedDateString["day-tens"] = ""; // Remove placeholder "d"
		}
	}

	// Refresh date display
	updateDateString();
	updateLivePreview("DateString",clickedDateString); // &#55357;&#56613; Placeholder for future function
}

/////////////////////////////////////////////////////////
//            FUNCTION - VALIDATE DATE (Standard)      //
/////////////////////////////////////////////////////////
function validateDate() {
    const day = clickedDateString["day-tens"] + clickedDateString["day-ones"];
    const month = clickedDateString["months"];
    const year = clickedDateString["centuries"] + clickedDateString["year-tens"] + clickedDateString["year-ones"];

    if (!day.includes("d") && !month.includes("Mmm") && !year.includes("y")) {
        const parsedDay = parseInt(day, 10);
        const parsedYear = parseInt(year, 10);

        if (!isValidDate(parsedDay, month, parsedYear)) {
            alert("That's not a valid date! Double-check your entry.");
        } else {
            // Check for future date
            const today = new Date();
            const enteredDate = new Date(parsedYear, getMonthIndex(month), parsedDay); 

            if (enteredDate > today) {
                alert("Where'd you get the 1.21 Gigawatts? That date is in the future!");
            }
        }
    }
}
function isValidDate(day, month, year) {
    const testDate = new Date(year, getMonthIndex(month), day);
    return testDate.getDate() === day;
}
function getMonthIndex(monthName) {
    const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    return months.indexOf(monthName);
}


/////////////////////////////////////////////////////////
//            FUNCTION - HANDLE Page Button Clicks     //
/////////////////////////////////////////////////////////
function handlePageClick(event) {
	const prefix = "Page ";
	let value = event.target.getAttribute("data-value");
	if (value === "del") {
		// Remove last character, including prefix if empty
		if (stdPageInput.value.length > 0) {
			stdPageInput.value = stdPageInput.value.slice(0, -1);	
		}
		if (stdPageInput.value === "Page ") {
			stdPageInput.value = "";
		}
	} else {
		// Append clicked value, adding "Page " if needed
		if (stdPageInput.value === "") {
			stdPageInput.value = prefix + value;
		} else if (stdPageInput.value.length < stdPageInput.maxLength) {
			stdPageInput.value += value;
		}
	}
	stdPageVar = stdPageInput.value;
	updateLivePreview("uLP - ",stdPageVar);
}


/////////////////////////////////////////////////////////
//                                                     //
//  Sect. 7 - POPULATE HTML (Dropdowns & Toggles)      //
//                                                     //
/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
//            FUNCTION - Populate BORDER Dropdown      //
/////////////////////////////////////////////////////////
function populateBorderSize() {
	const select = document.getElementById('bordersize');
	// Loop through the range from min to max, in increments of borderSizeInc
	for (let i = borderSizeMin; i <= borderSizeMax; i += borderSizeInc) {
		const option = document.createElement('option');
		option.value = i;
		option.textContent = i;
		// Set the selected option based on borderSize
		if (i === borderSize) {
			option.selected = true;
		}
		select.appendChild(option);
	}
}

/////////////////////////////////////////////////////////
//            FUNCTION - Populate FONT Dropdown        //
/////////////////////////////////////////////////////////
function populateFontType() {
    fontTypeSelect.innerHTML = ""; // Clear previous entries

    // Standard Fonts First
    standardFonts.forEach(font => {
        const option = document.createElement("option");
        option.value = font;
        option.textContent = font;
        if (font === selectedFont) option.selected = true;
        fontTypeSelect.appendChild(option);
    });

    // Load Custom Font If Enabled
    if (typeof customFontPath !== "undefined" && typeof customFontName !== "undefined") {
        const customFont = new FontFace(customFontName, `url(${customFontPath})`);

        customFont.load().then(function (loadedFont) {
            document.fonts.add(loadedFont);
            console.log(`Custom Font Loaded: ${loadedFont.family}`);

            // Add custom font to dropdown
            const option = document.createElement("option");
            option.value = loadedFont.family;
            option.textContent = loadedFont.family;
            if (loadedFont.family === selectedFont) option.selected = true;
            fontTypeSelect.appendChild(option);
        }).catch(err => console.warn("Custom font failed to load:", err));
    }
}


/////////////////////////////////////////////////////////
//            FUNCTION - Populate the Region dropdown  //
/////////////////////////////////////////////////////////
function populateRegionDropdown() {
	const regionDropdown = document.getElementById("stdRegion");
    
	Object.keys(newspaperRegions).forEach(region => {
		let option = document.createElement("option");
		option.value = region;
		option.textContent = region;
		if (region === selectedRegion) option.selected = true; // Preselect default
		regionDropdown.appendChild(option);
	});

	// Event listener to update newspapers when a region is selected
	regionDropdown.addEventListener("change", function () {
		selectedRegion = this.value;
		populateNewspaperDropdown();
	});
}

/////////////////////////////////////////////////////////
//            FUNCTION - Populate the Newspaper dropdn //
/////////////////////////////////////////////////////////
function populateNewspaperDropdown(skipflag) {
	const newspaperDropdown = document.getElementById("stdNewsDrop");
	newspaperDropdown.innerHTML = ""; // Clear existing options

	const regionKey = newspaperRegions[selectedRegion]; // Get the newspaper array name
	const newspaperList = window[regionKey]; // Fetch the array dynamically

	newspaperList.forEach(paper => {
		let option = document.createElement("option");
		option.value = paper;
		option.textContent = paper;
		newspaperDropdown.appendChild(option);
	});

	// Auto-select the first newspaper in the list
	if (newspaperList.length > 0) {
		newspaperDropdown.value = newspaperList[0];
		stdNewsInput.value = newspaperList[0]; // Autofill input
		stdNewsDrop = newspaperList[0];
		stdNewsVar = newspaperList[0];
	}
	if (skipflag) {
		newspaperDropdown.addEventListener("change", function() {
			stdNewsInput.value = this.value;
			stdNewsVar = this.value;
			updateLivePreview("New Newspaper");
		});
	} else {
		updateLivePreview("newspaper list update"); // &#55357;&#56613; Placeholder for future function
	}
} // end Populate Newspapers Function

/////////////////////////////////////////////////////////
//            FUNCTION - Std ItalicsButton Toggle      //
/////////////////////////////////////////////////////////
function toggleStandardItalic() {
	stdItalicsVar = !stdItalicsVar; // Toggle value
	const stdItalicsBtn = document.getElementById("stdItalics");

	// Toggle active class for styling
	stdItalicsBtn.classList.toggle("active", stdItalicsVar);

	// Apply italics to newspaper name input
	if (stdItalicsVar) {
		stdNewsInput.style.fontStyle = "italic";
	} else {
		stdNewsInput.style.fontStyle = "normal";
	}
	updateLivePreview("uLP - Std Italics");
}

/////////////////////////////////////////////////////////
//            FUNCTION - Custom Lines Toggle           //
/////////////////////////////////////////////////////////
function toggleCustomLine(lineNumber, enabled) {
	const overlay = document.getElementById(`customOverlay${lineNumber}`);
	if (overlay) {
		overlay.style.display = enabled ? "none" : "block";
	}
	customLinesEnabled[lineNumber - 1] = enabled;
	updateLivePreview("uLP - Cust Lines"); // &#55357;&#56613; Placeholder for live preview update
}

/////////////////////////////////////////////////////////
//            FUNCTION - status411 divs                //
/////////////////////////////////////////////////////////
function updateStatus411(data) { status411_gebi.innerHTML = data; }
function updateSnip411(data) { snip411_gebi.innerHTML = data; }
function updateChunk411(data) { chunk411_gebi.innerHTML = data; }
function updateTImgLoc411(data) { timgLoc411_gebi.innerHTML = data; }
function updateBImgPrevLoc411(data) { bimgPrev411_gebi.innerHTML = data; }
function updateBImgPostLoc411(data) { bimgPost411_gebi.innerHTML = data; }
function updateHOffset411(data) { Hoffset411_gebi.innerHTML = data; }
function updateVOffset411(data) { Voffset411_gebi.innerHTML = data; }
function updateCanvasSize411(data) { canvSize411_gebi.innerHTML = data; }
function updateTImgSize411(data) { timgSize411_gebi.innerHTML = data; }
function updateBImgSize411(data) { bimgSize411_gebi.innerHTML = data; }
function updateTransparency411(data) { trans411_gebi.innerHTML = `${data}%`; }
function updateImgCount411(data) { imgCount411_gebi.innerHTML = data; }
function updateRot411(data) { Rot411_gebi.innerHTML = data; }
// this may still go away...
function updateZoom411(data) { document.getElementById('Zoom411').innerHTML = data; }


/////////////////////////////////////////////////////////
//                                                     //
//  Sect. 8 - MISC FUNCTIONS                           //
//                                                     //
/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
//            FUNCTION - doneButton WAS CLICKED        //
/////////////////////////////////////////////////////////
function handleDoneClick() {
	switch(currStage) {
		case 'stitch':
			canPaste(false); // Turn off PASTE ability
			document.getElementById('hideBimg411').style.display = 'none';

			ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
			imageCanvas.width = (dispPadding * 2) + TImg.width;
			imageCanvas.height = (dispPadding * 2) + TImg.height;
			matchStyleToCanvas();

			// imageCanvas.height = TImg.height;
			updateCanvasSize411(`${imageCanvas.width}x${imageCanvas.height}`);
			ctx.drawImage(TImg, dispPadding, dispPadding, TImg.width, TImg.height);

			// Hide 'stitchTools' and show 'cropTools'
			stitchTools.style.display = 'none';
			cropTools.style.display = 'block';
			viewport.scrollTop = 0

			console.log("Stitching completed.");
			console.log("Starting crop and rotate.");
			currStage = 'crop'; // Move to the next stage

			cropCanvas.style.display = "block";
			updateStatus411('Rotate & Crop');
			initiateCropLines();
			addShade();
			break;

		case 'crop':
			// AFTER CROP...
			// Hide 'cropTools' and show 'textTools'
			cropTools.style.display = 'none';
			textTools.style.display = 'block';
			dimensionsBox.style.display = 'none';

			cropCanvas.style.display = "none";
			console.log("Cropping completed.");
			console.log("Starting append text.");
			currStage = 'text'; // Move to the next stage

			// Step 1: Apply crop on the original canvas (ctx)
			let cropWidth = CropLinesPos.r - CropLinesPos.l;
			let cropHeight = CropLinesPos.b - CropLinesPos.t;

			let croppedImageData = ctx.getImageData(CropLinesPos.l, CropLinesPos.t, cropWidth, cropHeight);

			// Step 2: Create a temporary canvas to hold the cropped image data
			let tempCanvas = document.createElement('canvas');
			let tempCtx = tempCanvas.getContext('2d');
		
			// Set the size of the temp canvas to match the cropped area
			tempCanvas.width = cropWidth;
			tempCanvas.height = cropHeight;
		
			// Step 3: Put the cropped image data on the temporary canvas
			tempCtx.putImageData(croppedImageData, 0, 0);
		
			// Step 4: Create a new image object (TImg) and set its source to the temporary canvas
			// let TImg = new Image();
			TImg.src = tempCanvas.toDataURL();  // Convert the canvas to a data URL and assign it to TImg

			TImg.onload = function() {
				updateStatus411('Append Text & Border');
				updateLivePreview();
			};
		break;

		case 'cut': // THIS IS SUSPENDED - AT LEAST TEMPORARILY
			// AFTER CUT
			console.log("Cutting completed.");
			currStage = 'text'; // Move to the next stage
		break;

		case 'text':
			// Perform text and border-related actions
			console.log("Text and border added.");
			textTools.style.display = 'none';
			downloadTools.style.display = 'block';
			doneButton.disabled = true;

			defaultFilename = `Clip_${new Date().toTimeString().slice(0, 8).replace(/:/g, '')}`;
			dlFilename.placeholder = defaultFilename;

			jpgSizeSpan.innerText = estimateFileSize("jpg");
			pngSizeSpan.innerText = estimateFileSize("png");
		break;

		default:
			console.log("Unknown stage - how'd you do that, kid?");
		break;
	}
} // end handleDoneClick

/////////////////////////////////////////////////////////
//            FUNCTION - MATCH STYLE TO CANVAS         //
/////////////////////////////////////////////////////////
function matchStyleToCanvas() {
	imageCanvas.style.width = `${imageCanvas.width}px`;
	imageCanvas.style.height = `${imageCanvas.height}px`;
}


/////////////////////////////////////////////////////////
//            FUNCTION - updateLivePreview  &#55357;&#56613;         //
/////////////////////////////////////////////////////////
function updateLivePreview(fullRedraw = true) {
    // Get TImg dimensions
    const imgWidth = TImg.naturalWidth;
    const imgHeight = TImg.naturalHeight;
    
    // Compute Auto-Fit sizes before determining textBoxHeight
    let autoFontSize = stdAutoFitEnabled ? computeAutoFontSize([stdNewsVar, `${stdDateVar} - ${stdPageVar}`], imgWidth) : stdFontSizeVar;
    stdFontSizeVar = autoFontSize;
    stdFontSizeDiv.innerHTML = autoFontSize;
    
    let customFontSizesAdjusted = customLinesEnabled.map((enabled, index) =>
        enabled && autoFitEnabled[index] ? computeAutoFontSize([customText[index]], imgWidth) : customFontSizes[index]
    );
    
    // Now calculate textBoxHeight using actual font sizes
    let textBoxHeight = 0;
    if (currentAppendLayout === "standard") {
        textBoxHeight = autoFontSize * 2;
    } else if (currentAppendLayout === "custom") {
        textBoxHeight = customFontSizesAdjusted.reduce((sum, size, index) => {
            return customLinesEnabled[index] ? sum + size : sum;
        }, 0);
    }
    
    // Calculate canvas size
    imageCanvas.width = imgWidth + (borderSize * 2);
    imageCanvas.height = imgHeight + (borderSize * 2) + textBoxHeight;
    matchStyleToCanvas(); 
    
    // Clear canvas
    ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
    
    // Draw background (which acts as border and text box background)
    ctx.fillStyle = imageBgColor;
    ctx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
    
    // Draw TImg onto the background
    ctx.drawImage(TImg, borderSize, borderSize);
    
    // Draw text
    ctx.fillStyle = textAppendColor;
    
    const textBoxY = borderSize + imgHeight;
    let currentY = textBoxY;
    
    if (currentAppendLayout === "standard") {
        ctx.textAlign = stdAlignment;
        let xPos = stdAlignment === "left" ? borderSize : stdAlignment === "right" ? imageCanvas.width - borderSize : imageCanvas.width / 2;
        
        ctx.font = `${stdBold ? "bold" : ""} ${stdItalicsVar ? "italic" : ""} ${autoFontSize}px ${selectedFont}`.trim();
        ctx.fillText(stdNewsVar, xPos, currentY + autoFontSize);
        
        ctx.font = `${stdBold ? "bold" : ""} ${autoFontSize}px ${selectedFont}`.trim();
        ctx.fillText(`${stdDateVar} - ${stdPageVar}`, xPos, textBoxY + textBoxHeight);
    } else if (currentAppendLayout === "custom") {
        customLinesEnabled.forEach((enabled, index) => {
            let fontSizeElement = document.getElementById(`custFontSize${index + 1}`);
            if (enabled) {
                ctx.textAlign = customAlignment[index];
                let xPos = customAlignment[index] === "left" ? borderSize : customAlignment[index] === "right" ? imageCanvas.width - borderSize : imageCanvas.width / 2;
                
                let autoFontSize = customFontSizesAdjusted[index];
			 customFontSizes[index] = autoFontSize;
                if (fontSizeElement) fontSizeElement.innerText = autoFontSize;
                
                ctx.font = `${customBold[index] ? "bold" : ""} ${customItalic[index] ? "italic" : ""} ${autoFontSize}px ${selectedFont}`.trim();
                ctx.fillText(customText[index], xPos, currentY + autoFontSize);
                currentY += autoFontSize;
            }
        });
    }
}

/////////////////////////////////////////////////////////
//            FUNCTION - computeAutoFontSize           //
/////////////////////////////////////////////////////////
function computeAutoFontSize(textArray, maxWidth) {
    let maxFontSize = 72;
    let minFontSize = 10;
    let testFont = `${maxFontSize}px ${selectedFont}`;
    ctx.font = testFont;
    
    for (let fontSize = maxFontSize; fontSize >= minFontSize; fontSize--) {
        ctx.font = `${fontSize}px ${selectedFont}`;
        let fits = textArray.every(text => ctx.measureText(text).width <= maxWidth);
        if (fits) return fontSize;
    }
    return minFontSize; // If nothing fits, return smallest size
}

/////////////////////////////////////////////////////////
//            FUNCTION - downloadImage                 //
/////////////////////////////////////////////////////////
function downloadImage(format) {
    // Use the existing defaultFilename set earlier (ensures no time mismatch)
	let filename = sanitizeFilename(dlFilename.value.trim()) || defaultFilename;

    // Determine the format
    let mimeType = format === "jpg" ? "image/jpeg" : "image/png";
    let quality = format === "jpg" ? jpgQuality : 1.0; // PNG is always lossless

    // Convert canvas to data URL
    let imageData = imageCanvas.toDataURL(mimeType, quality);

    // Create a download link
    let link = document.createElement("a");
    link.href = imageData;
    link.download = `${filename}.${format}`;

    // Trigger the download
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

/////////////////////////////////////////////////////////
//            FUNCTION - sanitizeFilename              //
/////////////////////////////////////////////////////////
function sanitizeFilename(input) {
    return input.replace(/(.*)\.(jpg|png)$/i, "$1"); 
}

/////////////////////////////////////////////////////////
//            FUNCTION - estimateFileSize              //
/////////////////////////////////////////////////////////
function estimateFileSize(format) {
    let mimeType = format === "jpg" ? "image/jpeg" : "image/png";
    let quality = format === "jpg" ? jpgQuality : 1.0; // PNG is always lossless

    // Generate Base64 Data URL (not saved, just used for size calc)
    let imageData = imageCanvas.toDataURL(mimeType, quality);

    // Convert Base64 string length to bytes (1 character = ~3/4 byte in Base64)
    let byteSize = Math.ceil((imageData.length - "data:image/png;base64,".length) * 0.75);

	// Convert to KB and MB (rounded for a true "estimate")
	let sizeKB = Math.round(byteSize / 1024);
	let sizeMB = Math.round(byteSize / (1024 * 1024));
	
	// Return as MB if it's 1MB or larger, otherwise return KB
	return sizeMB >= 1 ? `${sizeMB} MB` : `${sizeKB} KB`;
}


////////////////////////////////////////////// NO MAS WHEN FIN /////////////////////////////////////////////



/////////////////////////////////////////////////////////
//                                                     //
//              DRAG AND DROP FUNCTIONS                //
//                                                     //
/////////////////////////////////////////////////////////
//////////////// temp all disabled ///////////////
/*
let isDragging = false;
let mouseStartX, mouseStartY;  // Starting mouse position (X and Y) when drag begins
//let initialScrollPosition = 0;

// When mouse is pressed down
imageCanvas.addEventListener('mousedown', function(e) {
  isDragging = true;
  mouseStartX = e.clientX;  // Set the starting mouse X position
  mouseStartY = e.clientY;  // Set the starting mouse Y position
  imageCanvas.style.cursor = 'move';  // Change cursor to show dragging
});

// When mouse is moved
imageCanvas.addEventListener('mousemove', function(e) {
  if (!isDragging) return;
  
  const deltaX = e.clientX - mouseStartX;  // Calculate horizontal movement
  const deltaY = e.clientY - mouseStartY;  // Calculate vertical movement

  // Move the canvas by the delta (relative movement)
  imageCanvas.style.left = (imageCanvas.offsetLeft + deltaX) + 'px';
  imageCanvas.style.top = (imageCanvas.offsetTop + deltaY) + 'px';

  // Adjust the scroll position to avoid it getting stuck
  //viewport.scrollTop = initialScrollPosition + deltaY;

  mouseStartX = e.clientX; // Update the starting X position for the next movement
  mouseStartY = e.clientY; // Update the starting Y position for the next movement
});

// When mouse is released (dragging stops)
imageCanvas.addEventListener('mouseup', function() {
  isDragging = false;
  imageCanvas.style.cursor = 'default';  // Reset cursor
});

// Optionally, when the mouse leaves the canvas (in case of accidental drag out)
imageCanvas.addEventListener('mouseleave', function() {
  isDragging = false;
  imageCanvas.style.cursor = 'default';
});
*/
/////////////////// end drag and drop disable ///////////////













</script>